==================================
Exposure Related Objects and Forms
==================================

Before we get started, we need to import the required classes.  The
directories required should have been already set up by the script.
::

    >>> from pprint import pprint
    >>> from zope import interface
    >>> import zope.component
    >>> from Products.CMFCore.utils import getToolByName
    >>> from plone.z3cform.tests import setup_defaults
    >>> from pmr2.app.exposure.browser import browser as exposure
    >>> from pmr2.app.workspace import browser as workspace
    >>> from pmr2.app.tests.base import TestRequest
    >>> from pmr2.app.interfaces import *
    >>> from pmr2.app.workspace.content import *
    >>> from pmr2.app.workspace.interfaces import *
    >>> from pmr2.app.exposure.content import *
    >>> from pmr2.app.exposure.interfaces import *
    >>> pp = lambda x: pprint(x, indent=4, width=1)
    >>> catalog = getToolByName(self.portal, 'portal_catalog')

Create the exposure container.
::

    >>> self.portal['exposure'] = ExposureContainer()
    >>> self.portal.exposure
    <ExposureContainer at /plone/exposure>

Exposure container creates new exposure, we test it here.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/eggs',
    ...         'form.widgets.commit_id': u'00000000',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> oid = self.portal.exposure.objectIds()[0]
    >>> len(oid)
    32

Exposure object is created with fields properly populated.
::

    >>> self.portal.exposure[oid].workspace
    u'/plone/workspace/eggs'
    >>> self.portal.exposure[oid].commit_id
    u'00000000'

-----------------
Exposure creation
-----------------

Exposures can be created via the creation form defined here.
::

    >>> wkspc = self.portal.workspace.pmr2hgtest
    >>> request = TestRequest(form={'form.buttons.add': 1,})
    >>> form = exposure.CreateExposureForm(wkspc, request)
    >>> commit_id = self.pmr2hgtest_revs[-1]
    >>> form.traverse_subpath = [commit_id]
    >>> result = form()
    >>> next = request.response.getHeader('Location')
    >>> next
    'http://.../exposure/...'

The new exposure object should have the right values.
::

    >>> from zope.component import getUtility
    >>> from pmr2.app.interfaces import IPMR2GlobalSettings
    >>> settings = getUtility(IPMR2GlobalSettings)
    >>> frags = next.split('/')
    >>> eid = frags[-1]  # assume default_view == immediate_view in fti
    >>> exposures = settings.getExposureContainer()
    >>> new_exposure = exposures[eid]
    >>> new_exposure.workspace == wkspc.absolute_url_path()
    True
    >>> new_exposure.commit_id == commit_id
    True

Need test on the exposure listing and the rollover forms, namely for
user workspaces.

------------------------------------------------------------------------

========================
Exposure Files and Notes
========================

How exposures were originally implemented results in an explosion of
objects, as a result from one-to-many mapping from file to objects.

In the redesign introduced in v0.2, there is now only one object type
and only one of them per file.  Each of them will reference its source
file, and the custom views and data within are provided by adapters
which is extended off a standard adapter type.  The data generation is
no longer part of that class but be placed in its own, which can also be 
inherited to be reused by more complicated data processing methods.

This generalization will unify all views in the repository, result in
a standardized front page for each exposure and is significantly cleaner
than before.

-----------------------
Implementation Overview
-----------------------

To implement this feature, we will result in having objects in the
exposures having the exact same name as the file it represents.  This
will then require specific views to be registered for that content type
and have the view adapt to the correct persistent class it represents.

For example, in the workspace (http://models.example.com/w/test/) we 
have this directory structure:

  +\ ./
    | documentation.html
    | diagram.svg
   +\ import/
     | component-1.cellml
     | component-2.cellml
     | diagram.png
    | main-model.cellml
    | main-model_a.cellml
    | main-model_b.cellml

We must retain the access to the files as is.  However, sometimes it may
be beneficial to override that access to prevent certain kinds of attack
vectors.  For instance, documentation.html could contain scripts that
enable XSS attacks, so direct access to them through the exposure must
be sanitized (whereas through the workspace they must be sent as an
attachment).  The wrapper will also wrap the content of that file into
the page template.

Whereas the CellML files will need to be sent as raw, or rather be
redirected to the actual file, but then they do benefit from having
customized views (i.e. exposure pages).  The original implementation is
to add filename extensions to it, but ultimately this is proved to be
unflexible and clumsy - the hierarchy is all emulated, resulting in a
confused perception of the definitions of exposure pages and exposure
subpages.

Also, the original implementation does not include directories.

What I want is this - an object that can either refer to its real self
or the sanitized view (in the exposure), and to be able to provide
customized subviews.  More examples:

In exposure http://models.example.com/e/test/ (references same workspace
as above), we can have these objects:

  +\ ./
    | documentation.html
   +\ diagram.svg/
     | large.png
     | small.png
     | thumbnail.png
   +\ import/
    +\ component-1.cellml/
      | index
    +\ component-2.cellml/
      | index
    +\ diagram.png/
      | thumbnail.png
   +\ main-model.cellml/
     | index
     | metadata
     | code
   +\ main-model_a.cellml/
     | index
     | metadata
     | code
   +\ main-model_b.cellml/
     | index
     | metadata
     | code

Exposures require a descriptive index page that will give a complete
overview of what the model is, namely the curation status, key curation
information (citation and/or model authorship).  It will also list the
model files (usually are variants), giving a quick description of it 
based on metadata.

The object with the same name as the files in the workspace must be
able to perform these tasks:

  - get to the original file if configuration allows
  - present default views
  - also allow other custom views
  - contain other objects.

Each of these pages are not going to have its dedicated class (i.e. only
one page class), but adapters will be registered and will be used to
render and display.  Each of these pages will store the name of the
adapter used.  

Changes proposed here will mean redirections from the PMR2 v0.1 pages
to the new ones will need to take place.

In brief, there are these datatypes.

ExposureFolder
    Folder like object that exists solely to replicate any directory
    structures within its parents workspace.

ExposureFile
    Object in an Exposure that encapsulates its respective file within
    its parent's workspace.  May be nested inside ExposureFolder.

ExposureFileNote
    Persistent and Contained objects that wraps around the ExposureFile
    type.  Multiple ExposureFileAnnotator may make use of a single one
    of these.

    Views will need to be registered with ExposureFile, and those views
    will make use of these adapters
 
ExposureFileAnnotators
    Class that provides a generator method that will process the data.
    There may be different annotators that will use the same adapter
    types.

Associated Views
    Views are not exclusive with adapters, it just make use of the
    results that are stored within the adapters.  It may need some kind
    of method to determine whether it is active or not for the given
    ExposureFile object, as the data it requires may or may not be
    generated or available.

------------
Demostration
------------

Disclaimer: The doctests here only test the "workflow" (not Plone
workflow but how the objects are created/used), there isn't enough
testing of individual adapters (i.e. unit tests) written.

For this demo, we need to create an actual environment such that the
full demo can be appreciated.  We will use the environment that is
built in setup (uses pmr2.mercurial.tests) and create the exposure using
a workspace with actual data.
::

    >>> rev = unicode(self.pmr2hgtest_revs[1])
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/pmr2hgtest',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

Now we have an exposure, try to use one of its default views on it.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureInfo(context, request)
    >>> print view.render()
    <div></div>

As the exposure is a wrapper around the changeset of a workspace, all
paths within it should map correctly back to its source.  We can test
this feature using the testbrowser.  However, the testing stack does not
work correctly due to the differences between this and the paste/wsgi
framework that is used on an actual server, so an exception is raised
instead, but we have enough information to figure out that the correct
exception type (HTTPFound) is raised.

The reason why we raise HTTPFound is to skip the rest of the 
authentication steps for these nonexistential subpaths, not to mention
it raises security error.  If the security error can be debugged, the
standard way of using request.response.redirect(uri) can then be used.
::

    # XXX this is a broken test because login is required...
    # >>> from Products.Five.testbrowser import Browser
    # >>> browser = Browser()
    # >>> target = context.absolute_url() + '/file1'
    # >>> browser.open(target)
    # Traceback (most recent call last):
    # ...
    # HTTPError: HTTP Error 500: Internal Server Error
    # >>> browser.headers['bobo-exception-type']
    # 'HTTPFound'

We need to wrap around one of the interesting files inside with the
standard ExposureFile object.
::

    >>> pmr2hgtest = self.portal.workspace.pmr2hgtest
    >>> file1 = u'file1'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile1 = context[file1]
    >>> efile1
    <ExposureFile at ...>

We need a way to get to the content of the file.  I have generalized the
required methods into its own adapter, so we utilize it and call the
method that will return the source
::

    >>> helper = zope.component.queryAdapter(efile1, IExposureSourceAdapter)
    >>> answer = (context, pmr2hgtest, 'file1')
    >>> result = helper.source()
    >>> answer == result
    True

The adapter also provides a method that returns the contents of the file
that this represents.
::

    >>> helper.file()
    'This is file1, initial commit.\n'

Test it with the default view.  There should be no adapters added yet.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
    </dl>

The redirect view should redirect to the actual file within the 
workspace.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(context[file1], request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/pmr2hgtest/@@rawfile/.../file1'

Now we do the same with our set of data, with more content.
::

    >>> rawrevs = [
    ...     'b94d1701154be42acf63ee6b4bd4a99d09ba043c',
    ...     '2647d4389da6345c26d168bbb831f6512322d4f9',
    ...     '006f11cd9211abd2a879df0f6c7f27b9844a8ff2',
    ...     'eef1e9af39a79b2fc47ef978f8e61e853bad54e2',
    ... ]
    >>> rawrev = rawrevs[2]
    >>> rev = unicode(rawrev)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/rdfmodel',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

In order to annotate views to a file, we need to wrap around the target 
files with the standard ExposureFile object.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> file1 = u'example_model.cellml'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> context[file1]
    <ExposureFile at ...>

We will use the annotation form, which will get the annotator and 
annotate our ExposureFile content object.  Of course, first we have to
see whether the form has the annotator we needed.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> 'rdfturtle' in result
    True
    >>> 'rdfxml' in result  # for later usage
    True

Good, now we use that transform to generate the Turtle RDF.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rdfturtle'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
      <dt>rdfturtle</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.  Since we are constructing the view directly rather
than the component registry (as it is registered using the generated
class which we can't test in here), we manually assign its __name__

Also, the headers will need to be reassigned later as they are just
data (should not really be part of code).
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfturtle'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>...
    @prefix...
    ...

We will do the same thing with the xml format.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rdfxml'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
      <dt>rdfturtle</dt>
      <dt>rdfxml</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.  Since we are constructing the view directly rather
than the component registry (as it is registered using the generated
class which we can't test in here), we manually assign its __name__.

Also, the titles and descriptions will need to be reassigned later as 
they are just data (should not really be part of code).
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfxml'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;rdf:RDF
    ...

Of course assignment to this new set of data, it will not overwrite the
other note class because it has a distinct annotation key.
::

    >>> request = TestRequest()
    >>> view = exposure.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfturtle'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>...
    @prefix...
    ...

This way it becomes a lot easier to provide new content and associated
views to a file that requires processing.  One only need to define an
ExposureFile adapter class and an utility class that will populate the
data for that class.  The view would then access the data stored within
that adapter.

It may be necessary to group some of these subparts together.  Since
all those views are derived from RDF, it makes sense to have a single
@@rdf view with subpaths to the particular format.  First we query the
view and see that it will return a list by default
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), name='rdf')
    >>> view = view.form_instance  # take what we defined.
    >>> print view()
    <h3>RDF views available</h3>
    <p>The following is a list of available choices</p>
    <ul>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/n3">n3</a>
    </li>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/turtle">turtle</a>
    </li>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/xml">xml</a>
    </li>
    </ul>

If we define a valid subpath, it will give what we expect.
::

    >>> view.traverse_subpath = ['xml']
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;rdf:RDF
    ...

There are cases where user-edited notes are desired.  Here we test out 
editing first on the note editor/annotator
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'edited_note'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True
    >>> request.response.getHeader('Location')
    'http://.../example_model.cellml/@@note_editor/edited_note'

We should have been a redirect to the edit view.  The editor view is
defined without any default fields, so it must figure out the correct
fields from the name of the note from the URI supplied.  We replicate
what the request would see here and render the note edit view.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = ['edited_note']
    >>> result = view()
    >>> 'note' in result
    True

The form is rendered correctly when a defined subpath is supplied.  If
no subpath or one is not meant to be user editable is supplied, it will
result in a not found error.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = []
    >>> view()
    Traceback (most recent call last):
    ...
    HTTPNotFound: 404 Not Found
    ...
    >>> view.traverse_subpath = ['rdf']
    >>> view()
    Traceback (most recent call last):
    ...
    HTTPNotFound: 404 Not Found
    ...

Then apply on the edit form for the note, and the note will have its
field updated.
::

    >>> note = u'This is a test note'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.note': note,
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = ['edited_note']
    >>> result = view()

Now if we call the edited_note view for the file, the page will be
rendered.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='edited_note')
    >>> result = view()
    >>> print result
    Edited Note is: [This is a test note]

This should also be available as a new view that is attached to filectx.
::

    >>> 'edited_note' in filectx.views
    True

There are cases where user intervention is required for generating a
note from the file.  This example shows that a user may select the
number of characters from the original file to include in the resulting
note.  We will do this on a new file.
::

    >>> context['README'] = ExposureFile('README')
    >>> readmectx = context['README']
    >>> chars = u'15'
    >>> text = u'This will be replaced'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.chars': chars,
    ...         'form.widgets.text': text,
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileNoteEditForm(readmectx, request)
    >>> view.traverse_subpath = ['post_edited_note']
    >>> result = view()

The data should have been generated correctly and the view rendered.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((readmectx, request), 
    ...                                         name='post_edited_note')
    >>> result = view()
    >>> print result
    Post Edited Note is: [15:This is an exam]

------------------------
Files within Directories
------------------------

We however only looked at files sitting at the root level.  There are
many cases where files will be nested within some directory level which
we have not looked at yet.  Let's see what happens when we try that.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path2 = (u'component', u'module.cellml')
    >>> file2 = '/'.join(path2)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file2],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

It should also be able to redirect to the correct file within its source
workspace.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile2, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/module.cellml'

We can try the same with another nested file.  Since the 'component'
folder is already created, it should not be recreated and reused and
remain accessible.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path3 = (u'component', u'docs', u'index.html')
    >>> file3 = '/'.join(path3)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file3],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile3 = context[path3[0]][path3[1]][path3[2]]
    >>> efile3
    <ExposureFile at ...>
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

Again, redirection should remain in place.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile3, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.html'

One more time, with the other index file, and go straight to testing
the redirection view.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path4 = (u'component', u'docs', u'index.rst')
    >>> file4 = '/'.join(path4)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file4],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile4 = context[path4[0]][path4[1]][path4[2]]
    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile4, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.rst'

It is possible to define a custom note adapter with its own view and
annotator to store custom-defined values, and this is the preferred
method for it allows plugin writers to define exactly how the data is
to be generated, stored, and presented.

While it is possible to rely on multiple note adapters to achieve the
same goal, it cannot be guarantee that the stored data can be accessed
correctly for the adapters relied on may change or become absent, thus
potentially breaking the annotators and cause data loss.

---------------------
Default Document View
---------------------

This is the case where multiple generators can be used to result in a
same view.  Since the ExposureFile is built on top of the standard 
Document archetype, we may have different file formats that require
different rendering methods.

For the HTML file
::

    >>> filectx = efile3
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureDocViewGenForm(filectx, request)
    >>> result = view()
    >>> filectx.Title()
    'Simple HTML'
    >>> filectx.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> filectx.docview_generator
    u'safe_html'

For the reStructureText file
::

    >>> filectx = efile4
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [],
    ...         'form.widgets.docview_generator': [u'rest_to_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureDocViewGenForm(filectx, request)
    >>> result = view()
    >>> filectx.getText()
    '<h2 class="title">Simple reStructureText</h2>\n<p>...</p>\n'
    >>> filectx.docview_generator
    u'rest_to_html'

As the annotator classes are separate from the data adapters, we can
easily reuse them for the other types, such as the default view of the
Exposures.  With this form we pick a file for the source of our text,
and the annotator to process it with.  We can pick any file.
::

    >>> context
    <Exposure at ...>
    >>> source_file = u'component/docs/index.html'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='docviewgen')
    >>> result = view.form_instance()
    >>> result
    ''
    >>> context.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> context.docview_generator
    u'safe_html'
    >>> context.docview_gensource == source_file
    True

ExposureFiles can also reference a separate file for its documentation.
::

    >>> source_file = u'component/docs/index.html'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((efile2, request), 
    ...                                         name='docviewgen')
    >>> result = view.form_instance()
    >>> result
    ''
    >>> efile2.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> efile2.docview_generator
    u'safe_html'
    >>> efile2.docview_gensource == source_file
    True

Ditto for ExposureFolders.
::

    >>> source_file = u'component/README'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> edir1 = context[path4[0]]
    >>> view = zope.component.queryMultiAdapter((edir1, request), 
    ...                                         name='docviewgen')
    >>> result = view.form_instance()
    >>> result
    ''
    >>> 'This is a readme file inside the component directory.' in \
    ...     edir1.getText()
    True
    >>> edir1.docview_generator
    u'safe_html'
    >>> edir1.docview_gensource == source_file
    True

We could try to render it, and this will be done on the html file at
`component/docs/index.html`.
::

    >>> filectx = efile3
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                         name='exposure_file_document_view')
    >>> result = view()
    >>> 'Lorem ipsum dolar sit amet' in result
    True

So standard document view is rendered.  We can now select one of the
annotations as the default view, using the form.  First we render the
form and make sure the choices are all rendered.  The file we will use
is `example_model.cellml`.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view.form_instance()
    >>> [i in result for i in filectx.views]
    [True, True, True]

Now select one of those views to change the default view from the
document_view to one provided by the notes.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.selected_view': [u'edited_note'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view.form_instance()
    >>> filectx.selected_view == u'edited_note'
    True

The view should render with the edited_note as selected.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view.form_instance()
    >>> u'selected="selected">edited_note</option>' in result
    True

What if the views that are saved had been changed or removed?  The form
should not break because the selection is no longer there.
::

    >>> views = filectx.views  # save original value
    >>> filectx.views = []
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view.form_instance()
    >>> u'edited_note' not in result
    True
    >>> filectx.views = views  # reset original value

Now the same document view rendering will result in the same view as the
edited_note.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                         name='exposure_file_document_view')
    >>> result = view()
    >>> print result
    Edited Note is: [This is a test note]

-----------------
Exposure Rollover
-----------------

As exposures are pinned to specific revisions even though new changesets
are added.  Users may want to have a new exposure point to a newer
revision but not want to manually readd to recreate the exposure and its
associated files.  The feature 'Exposure Rollover' is introduced to 
automate the process of recreating the files and its associated views.

(Yes, the following should have its own unit tests, but for now we at
least need some integration/functional tests)

First a structure that represents an exposure is generated, which
contains all the information required to automatically regenerate an 
identical new object hierarchy if all files exists at the newly pinned
commit id.  We will use the data we created from above, and call the 
utility defined for this task.
::

    >>> context
    <Exposure at /.../exposure/...>
    >>> context.curation = {'key': ['value1', 'value2']}
    >>> context.setSubject(('Test',))
    >>> porter = exposure.ExposurePort(context, None)
    >>> result = list(porter.export())
    >>> answer = [
    ...     ('example_model.cellml', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'views': [
    ...             (u'rdfturtle', None),
    ...             (u'rdfxml', None),
    ...             (u'edited_note', {
    ...                 'note': u'This is a test note',
    ...             }),
    ...         ],
    ...         'selected_view': u'edited_note',
    ...         'Subject': (),
    ...     }),
    ...     ('README', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'views': [
    ...             (u'post_edited_note', {
    ...                 'chars': 15,
    ...                 'text': u'This is an exam',
    ...             }),
    ...         ],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/module.cellml', {
    ...         'file_type': None,
    ...         'docview_gensource': u'component/docs/index.html',
    ...         'docview_generator': u'safe_html',
    ...         'views': [],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/docs/index.html', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': u'safe_html',
    ...         'views': [],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/docs/index.rst', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': u'rest_to_html',
    ...         'views': [],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/docs', {
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component', {
    ...         'docview_gensource': u'component/README',
    ...         'docview_generator': u'safe_html',
    ...         'Subject': (),
    ...     }),
    ...     ('', {
    ...         'commit_id': u'006f11cd9211abd2a879df0f6c7f27b9844a8ff2',
    ...         'curation': {'key': ['value1', 'value2']},
    ...         'docview_generator': u'safe_html',
    ...         'docview_gensource': u'component/docs/index.html',
    ...         'title': u'Simple HTML',
    ...         'workspace': u'/plone/workspace/rdfmodel',
    ...         'Subject': ('Test',),
    ...     })
    ... ]
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Once we know it will return the expected structure, we can expect the
porter to be able to recreate the same exposure with the same commit.
First we need need a new exposure object.
::

    >>> old_ex = context
    >>> eaf = exposure.ExposureAddForm(self.portal.exposure, None)
    >>> rawrev = rawrevs[2]
    >>> rev = unicode(rawrev)
    >>> data = {
    ...     'workspace': u'/plone/workspace/rdfmodel',
    ...     'curation': None,
    ...     'commit_id': rev,
    ... }
    >>> obj = eaf.createAndAdd(data)
    >>> exp_id = data['id']
    >>> new_ex = self.portal.exposure[exp_id]
    >>> new_ex
    <Exposure at /.../exposure/...>
    >>> new_ex == old_ex
    False

Now we use the porter to mold the new exposure based on what it knows.
::

    >>> porter.mold(new_ex)
    >>> newport = exposure.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

The ExposurePort class can be subclassed into customized forms, 
depending on how the upgrade process is presented.  Here we have a form
that is based on the old context, takes the next commit id.  We can
supply an existing commit id.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='rollover')
    >>> result = view.form_instance()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex = self.portal.exposure[new_id]
    >>> newport = exposure.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

It should work for all other commits.  The only difference would be the
edited note.  We will need to make a deep copy of the original answer
and update the post edited note with the contents of the file in that
commit.
::

    >>> from copy import deepcopy
    >>> rev2_answer = answer
    >>> rev = unicode(rawrevs[3])
    >>> answer = deepcopy(answer)
    >>> answer[-1][1]['commit_id'] = rev
    >>> answer[1][1]['views'] = [
    ...         (u'post_edited_note', {
    ...             'chars': 15,
    ...             'text': u'README for this',
    ...         }),
    ...     ]
    ...
    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='rollover')
    >>> result = view.form_instance()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex = self.portal.exposure[new_id]
    >>> newport = exposure.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Rollovers via workspace
-----------------------

Currently, the more accessible, easier to use form for this rollover
feature is attached to a view within workspaces.  We can achieve this
by instantiating the form from one.

First we verify that the form contain the fields we are interested in,
with the radio boxes available to be selected.
::

    >>> context = self.portal.workspace['rdfmodel']
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                          name='exposure_rollover')
    >>> result = view.form_instance()
    >>> '006f11cd9211abd2a879df0f6c7f27b9844a8ff2' in result
    True
    >>> '<td><label><input type="radio" class="radio-widget" ' \
    ... 'name="form.widgets.commit_id" ' \
    ... 'value="eef1e9af39a79b2fc47ef978f8e61e853bad54e2"  /> ' \
    ... 'eef1e9af39a7</label></td>' in result
    True
    >>> '<input type="radio" class="radio-widget" ' \
    ... 'name="form.widgets.exposure_path"' in result
    True

Then we can submit the form, and see that the data still match.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.widgets.exposure_path': '/plone/exposure/%s' % new_id,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view.form_instance()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> next_id = nextURL.split('/')[-1]
    >>> next_ex = self.portal.exposure[next_id]
    >>> nextport = exposure.ExposurePort(next_ex, None)
    >>> result = list(nextport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Errors cases
------------

There are ways to submit this form using bad information.  Those will 
need to be handled.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.widgets.exposure_path': u'',
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view.form_instance()
    >>> request.response.getHeader('Location')

The correctly selected value should have been selected, but it is not
enabled at this point.
::

    >>> '<td><label><input type="radio" class="radio-widget" ' \
    ... 'name="form.widgets.commit_id" ' \
    ... 'value="eef1e9af39a79b2fc47ef978f8e61e853bad54e2" ' \
    ... 'selected="selected" />' in result
    False

Miscellenous
------------

Need a test case to handle file name changes, either through move or
delete.

Need to test this with the catalog, such that the results can still be
queried.

Also need to filter out incompatible objects.

------------------
Exposure File Type
------------------

There are cases where specific types of files will always have the same
views generated.  PMR2 also provides a content type that enables users
to define a profile of sort for specific file types.  This allows the
annotation form to generate the correct views and arrange them in the
correct order, optinally select the right one, and tag the file with the
tags specified.

First we create one via the form.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.id': u'dummy_type',
    ...         'form.widgets.title': u'Dummy Type',
    ...         'form.widgets.views': u'edited_note\npost_edited_note',
    ...         'form.widgets.select_view': u'edited_note',
    ...         'form.widgets.tags': u'Notes',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileTypeAddForm(self.portal, request)
    >>> testform.update()
    >>> self.portal.dummy_type
    <ExposureFileType at /plone/dummy_type>
    >>> self.portal.dummy_type.views
    [u'edited_note', u'post_edited_note']
    >>> self.portal.dummy_type.select_view
    u'edited_note'

This new data should have been indexed.
::

    >>> results = catalog(portal_type='ExposureFileType')
    >>> results[0].pmr2_eftype_views
    [u'edited_note', u'post_edited_note']

The data could also be edited via the edit form.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.id': u'dummy_type',
    ...         'form.widgets.title': u'Dummy Type',
    ...         'form.widgets.views': u'rot13\npost_edited_note\nedited_note',
    ...         'form.widgets.select_view': u'post_edited_note',
    ...         'form.widgets.tags': u'Notes',
    ...         'form.buttons.apply': 1,
    ...     })
    >>> testform = exposure.ExposureFileTypeEditForm(
    ...     self.portal.dummy_type, request)
    >>> testform.update()
    >>> self.portal.dummy_type.views
    [u'rot13', u'post_edited_note', u'edited_note']
    >>> self.portal.dummy_type.select_view
    u'post_edited_note'

The cataloged data should have been updated also.
::

    >>> results = catalog(portal_type='ExposureFileType')
    >>> results[0].pmr2_eftype_views
    [u'rot13', u'post_edited_note', u'edited_note']
    >>> self.portal.dummy_type.select_view
    u'post_edited_note'

Before the next test, we need to publish the dummy type to make it
available for use.
::

    >>> self.setRoles(('Manager',))
    >>> wft = getToolByName(self.portal, 'portal_workflow')
    >>> wft.doActionFor(self.portal.dummy_type, 'publish')

They will populate the selections available within the annotation by
filetype form.
::

    >>> request = TestRequest()
    >>> efile_new = new_ex.component.docs['index.html']
    >>> form = exposure.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> 'Dummy Type' in result
    True
    >>> '/plone/dummy_type' in result
    False

We can choose to not use the predefined type and assign views manually,
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rot13', u'post_edited_note'],
    ...         'form.buttons.next': 1,
    ...     })
    >>> form = exposure.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> request.response.getHeader('Location')
    'http://nohost/plone/.../@@edit_annotations'

The fields and the views selected should have been applied to our 
context.
::

    >>> efile_new.views
    [u'rot13', u'post_edited_note']
    >>> efile_new.file_type
    >>> efile_new.Subject()
    ()

Or chooose the defined type, which will assign the view, file type and
tag the file with the appropriate subjects.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.eftypes': [u'Dummy Type'],
    ...         'form.buttons.next': 1,
    ...     })
    >>> form = exposure.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> request.response.getHeader('Location')
    'http://nohost/plone/.../@@edit_annotations'

The fields and the views selected should have been applied to our 
context.
::

    >>> efile_new.views
    [u'rot13', u'post_edited_note', u'edited_note']
    >>> efile_new.file_type
    '/plone/dummy_type'
    >>> efile_new.Subject()
    ('Notes',)

The next form should contain all the fields specified for editing.
::

    >>> request = TestRequest()
    >>> form = exposure.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> form.update()
    >>> [g.fields.keys() for g in form.groups]
    [[], ['post_edited_note.chars'], ['edited_note.note']]

Rendering of the form should not cause side effects, which in this case
add the annotation to the context before the values are ready.
::

    >>> from pmr2.app.annotation.factory import has_note
    >>> True in [has_note(efile_new, name) for name in efile_new.views]
    False

When this form is sucessfully submitted, the annotations will be
generated and added.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.post_edited_note.chars': u'15',
    ...         'form.widgets.edited_note.note': u'User Edited Data.',
    ...         'form.buttons.apply': 1,
    ...     })
    >>> form = exposure.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> result = form()

All three annotations should have worked, with its appropriate notes
generated.
::

    >>> n = zope.component.queryAdapter(efile_new, name='rot13')
    >>> n.text
    u'<ugzy>...
    >>> n = zope.component.queryAdapter(efile_new, name='post_edited_note')
    >>> n.chars
    15
    >>> n.text
    u'<html>\n<head><t'
    >>> n = zope.component.queryAdapter(efile_new, name='edited_note')
    >>> n.note
    u'User Edited Data.'

The other attributes to the exposure file should also have been set.
::

    >>> efile_new.selected_view
    u'post_edited_note'

When requesting this form again, the edited widgets should have the
values assigned above filled in.
::

    >>> request = TestRequest()
    >>> form = exposure.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> result = form()
    >>> u'User Edited Data.' in result
    True

Finally, we test that these data will also work with the migration.
::

    >>> rev = unicode(rawrevs[3])
    >>> answer[3][1]['file_type'] = '/plone/dummy_type'
    >>> answer[3][1]['Subject'] = ('Notes',)
    >>> answer[3][1]['selected_view'] = u'post_edited_note'
    >>> answer[3][1]['views'] = [
    ...         (u'rot13', None),
    ...         (u'post_edited_note', {
    ...             'chars': 15,
    ...             'text': u'<html>\n<head><t',
    ...         }),
    ...         (u'edited_note', {
    ...             'note': u'User Edited Data.',
    ...         }),
    ...     ]
    ...
    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((new_ex, request), 
    ...                                         name='rollover')
    >>> result = view.form_instance()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex2 = self.portal.exposure[new_id]
    >>> newport = exposure.ExposurePort(new_ex2, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

------------------
Note Rearrangement
------------------

There is also an edit view that will allow users to rearrange and/or
remove views.  It will remove any bad views.  First we render the form
::

    >>> ef = new_ex['example_model.cellml']
    >>> ef.views
    [u'rdfturtle', u'rdfxml', u'edited_note']
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((ef, request), 
    ...                                         name='arrange_views')
    >>> result = view.form_instance()
    >>> '>rdfturtle\nrdfxml\nedited_note</textarea>' in result
    True

Now for the actual request to change values
::

    >>> request = TestRequest(form={
    ...    'form.widgets.views': u'edited_note\n'
    ...                           'rdfxml\n'
    ...                           'baddata\n'
    ...                           'rdfturtle\n',
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((ef, request), 
    ...                                         name='arrange_views')
    >>> result = view.form_instance()
    >>> ef.views
    [u'edited_note', u'rdfxml', u'rdfturtle']
