==================================
Exposure Related Objects and Forms
==================================

Before we get started, we need to import the required classes.  The
directories required should have been already set up by the script.
::

    >>> from pprint import pprint
    >>> from zope import interface
    >>> import zope.component
    >>> from Products.CMFCore.utils import getToolByName
    >>> from pmr2.testing.base import TestRequest
    >>> from pmr2.app.exposure.browser import browser
    >>> from pmr2.app.exposure.browser import workspace
    >>> from pmr2.app.exposure.browser import util
    >>> from pmr2.app.interfaces import *
    >>> from pmr2.app.workspace.content import *
    >>> from pmr2.app.workspace.interfaces import *
    >>> from pmr2.app.exposure.content import *
    >>> from pmr2.app.exposure.interfaces import *
    >>> pp = lambda x: pprint(x, indent=4, width=1)
    >>> catalog = getToolByName(self.portal, 'portal_catalog')

We use the simple exposure add form, which is the parent class for a
number of forms.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/blank',
    ...         'form.widgets.commit_id': u'0',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> oid = self.portal.exposure.objectIds()[0]
    >>> len(oid) in [1, 32]  # depends on which one is active.
    True

Exposure object is created with fields properly populated.
::

    >>> self.portal.exposure[oid].workspace
    u'/plone/workspace/blank'
    >>> self.portal.exposure[oid].commit_id
    u'0'

--------------------------------------------
Exposure creation from a workspace changeset
--------------------------------------------

Exposures can be created via the creation form defined for usage from
a workspace via this traverse enabled form.
::

    >>> wkspc = self.portal.workspace.pmr2hgtest
    >>> request = TestRequest(form={'form.buttons.add': 1,})
    >>> form = workspace.CreateExposureForm(wkspc, request)
    >>> commit_id = u'7'
    >>> form.traverse_subpath = [commit_id]
    >>> result = form()
    >>> next = request.response.getHeader('Location')
    >>> next
    'http://.../exposure/...'

The new exposure object should have the right values.
::

    >>> from zope.component import getUtility
    >>> from pmr2.app.settings.interfaces import IPMR2GlobalSettings
    >>> settings = getUtility(IPMR2GlobalSettings)
    >>> frags = next.split('/')
    >>> eid = form.ctxobj.id
    >>> exposures = settings.getExposureContainer()
    >>> new_exposure = exposures[eid]
    >>> new_exposure.workspace == wkspc.absolute_url_path()
    True
    >>> new_exposure.commit_id == commit_id
    True

Optionally, the user can fill out some information to get started on the
exposure wizard.
::

    >>> wkspc = self.portal.workspace.test
    >>> request = TestRequest(
    ...     form={
    ...         'view.widgets.docview_generator': 'safe_html',
    ...         'view.widgets.docview_gensource': 'file2',
    ...         'form.buttons.add': 1,
    ...     })
    >>> form = workspace.CreateExposureForm(wkspc, request)
    >>> commit_id = '1'
    >>> form.traverse_subpath = [commit_id]
    >>> result = form()
    >>> next = request.response.getHeader('Location')
    >>> next
    'http://.../exposure/...'
    >>> wh = zope.component.getAdapter(form.ctxobj, IExposureWizard)
    >>> result = wh.structure
    >>> answer = [
    ...     ('', {
    ...         'commit_id': u'1',
    ...         'curation': {},
    ...         'docview_generator': u'safe_html',
    ...         'docview_gensource': u'file2',
    ...         'title': u'',
    ...         'workspace': u'/plone/workspace/test',
    ...         'Subject': (),
    ...     })
    ... ]
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

If the file entry is includled, a file entry should be generated.
::

    >>> wkspc = self.portal.workspace.test
    >>> request = TestRequest(
    ...     form={
    ...         'file.widgets.filetype': 'Test Type',
    ...         'file.widgets.filename': 'file2',
    ...         'view.widgets.docview_generator': 'safe_html',
    ...         'view.widgets.docview_gensource': 'file2',
    ...         'form.buttons.add': 1,
    ...     })
    >>> form = workspace.CreateExposureForm(wkspc, request)
    >>> commit_id = '1'
    >>> form.traverse_subpath = [commit_id]
    >>> result = form()
    >>> next = request.response.getHeader('Location')
    >>> next
    'http://.../exposure/...'
    >>> wh = zope.component.getAdapter(form.ctxobj, IExposureWizard)
    >>> result = wh.structure
    >>> answer = [
    ...     ('file2', {
    ...         'file_type': '/plone/test_type',
    ...         'Subject': [u'please_ignore'],
    ...         'selected_view': None,
    ...         'hidden_views': [],
    ...         'views': [
    ...             (u'edited_note', None),
    ...             (u'post_edited_note', None),
    ...             (u'rot13', None),
    ...         ],
    ...     }),
    ...     ('', {
    ...         'commit_id': u'1',
    ...         'curation': {},
    ...         'docview_generator': u'safe_html',
    ...         'docview_gensource': u'file2',
    ...         'title': u'',
    ...         'workspace': u'/plone/workspace/test',
    ...         'Subject': (),
    ...     })
    ... ]
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Need test on the exposure listing and the rollover forms, namely for
user workspaces.

------------------------------------------------------------------------

========================
Exposure Files and Notes
========================

How exposures were originally implemented results in an explosion of
objects, as a result from one-to-many mapping from file to objects.

In the redesign introduced in v0.2, there is now only one object type
and only one of them per file.  Each of them will reference its source
file, and the custom views and data within are provided by adapters
which is extended off a standard adapter type.  The data generation is
no longer part of that class but be placed in its own, which can also be 
inherited to be reused by more complicated data processing methods.

This generalization will unify all views in the repository, result in
a standardized front page for each exposure and is significantly cleaner
than before.

-----------------------
Implementation Overview
-----------------------

To implement this feature, we will result in having objects in the
exposures having the exact same name as the file it represents.  This
will then require specific views to be registered for that content type
and have the view adapt to the correct persistent class it represents.

For example, in the workspace (http://models.example.com/w/test/) we 
have this directory structure:

  +\ ./
    | documentation.html
    | diagram.svg
   +\ import/
     | component-1.cellml
     | component-2.cellml
     | diagram.png
    | main-model.cellml
    | main-model_a.cellml
    | main-model_b.cellml

We must retain the access to the files as is.  However, sometimes it may
be beneficial to override that access to prevent certain kinds of attack
vectors.  For instance, documentation.html could contain scripts that
enable XSS attacks, so direct access to them through the exposure must
be sanitized (whereas through the workspace they must be sent as an
attachment).  The wrapper will also wrap the content of that file into
the page template.

Whereas the CellML files will need to be sent as raw, or rather be
redirected to the actual file, but then they do benefit from having
customized views (i.e. exposure pages).  The original implementation is
to add filename extensions to it, but ultimately this is proved to be
unflexible and clumsy - the hierarchy is all emulated, resulting in a
confused perception of the definitions of exposure pages and exposure
subpages.

Also, the original implementation does not include directories.

What I want is this - an object that can either refer to its real self
or the sanitized view (in the exposure), and to be able to provide
customized subviews.  More examples:

In exposure http://models.example.com/e/test/ (references same workspace
as above), we can have these objects:

  +\ ./
    | documentation.html
   +\ diagram.svg/
     | large.png
     | small.png
     | thumbnail.png
   +\ import/
    +\ component-1.cellml/
      | index
    +\ component-2.cellml/
      | index
    +\ diagram.png/
      | thumbnail.png
   +\ main-model.cellml/
     | index
     | metadata
     | code
   +\ main-model_a.cellml/
     | index
     | metadata
     | code
   +\ main-model_b.cellml/
     | index
     | metadata
     | code

Exposures require a descriptive index page that will give a complete
overview of what the model is, namely the curation status, key curation
information (citation and/or model authorship).  It will also list the
model files (usually are variants), giving a quick description of it 
based on metadata.

The object with the same name as the files in the workspace must be
able to perform these tasks:

  - get to the original file if configuration allows
  - present default views
  - also allow other custom views
  - contain other objects.

Each of these pages are not going to have its dedicated class (i.e. only
one page class), but adapters will be registered and will be used to
render and display.  Each of these pages will store the name of the
adapter used.  

Changes proposed here will mean redirections from the PMR2 v0.1 pages
to the new ones will need to take place.

In brief, there are these datatypes.

ExposureFolder
    Folder like object that exists solely to replicate any directory
    structures within its parents workspace.

ExposureFile
    Object in an Exposure that encapsulates its respective file within
    its parent's workspace.  May be nested inside ExposureFolder.

ExposureFileNote
    Persistent and Contained objects that wraps around the ExposureFile
    type.  Multiple ExposureFileAnnotator may make use of a single one
    of these.

    Views will need to be registered with ExposureFile, and those views
    will make use of these adapters
 
ExposureFileAnnotators
    Class that provides a generator method that will process the data.
    There may be different annotators that will use the same adapter
    types.

Associated Views
    Views are not exclusive with adapters, it just make use of the
    results that are stored within the adapters.  It may need some kind
    of method to determine whether it is active or not for the given
    ExposureFile object, as the data it requires may or may not be
    generated or available.

------------------
Base Demonstration
------------------

First navigate to the exposure add form at one of the demo workspace
with a dummy workspace.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/test',
    ...         'form.widgets.commit_id': u'0',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

Now we can add a file to display.  First we render the form that will
let us add the file to the exposure.
::

    >>> request = TestRequest()
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> result = testform()

Since we used one of the earlier revisions, the list of files provided
in the options should only contain these entries and not ones that are
found in later revisions.
::

    >>> 'file1' in result
    True
    >>> 'file2' in result
    True
    >>> 'file3' in result
    False
    >>> 'dir1' in result
    False

We still need to submit this form to see that all the internal bits are
all working correctly.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [u'file2'],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> result = context['file2']
    >>> result
    <ExposureFile at /plone/.../file2>

--------------------------------
Demostration with pmr2.mercurial
--------------------------------

Disclaimer: The doctests here only test the "workflow" (not Plone
workflow but how the objects are created/used), there isn't enough
testing of individual adapters (i.e. unit tests) written.

For this demo, we need to create an actual environment such that the
full demo can be appreciated.  We will use the environment that is
built in setup (uses pmr2.mercurial.tests) and create the exposure using
a workspace with actual data.
::

    >>> rev = u'1'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/pmr2hgtest',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

Now we have an exposure, try to use one of its default views on it.  As
this is a fresh exposure without any files created for it, render should
return a fairly blank result and not trigger any redirection.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureInfo(context, request)
    >>> view.update()
    >>> print view.render()
    <h1 class="documentFirstHeading">...</h1>
    <div id="content-core">
      <div></div>
    </div>
    >>> request.response.getHeader('Location') is None
    True

As the exposure is a wrapper around the changeset of a workspace, all
paths within it should map correctly back to its source.  We can test
this feature using the testbrowser.  However, the testing stack does not
work correctly due to the differences between this and the paste/wsgi
framework that is used on an actual server, so an exception is raised
instead, but we have enough information to figure out that the correct
exception type (Redirect) is raised.

The reason why we raise Redirect is to skip the rest of the 
authentication steps for these nonexistential subpaths, not to mention
it raises security error.  If the security error can be debugged, the
standard way of using request.response.redirect(uri) can then be used.
::

    # XXX this is a broken test because login is required...
    # >>> from Products.Five.testbrowser import Browser
    # >>> b = Browser()
    # >>> target = context.absolute_url() + '/file1'
    # >>> b.open(target)
    # Traceback (most recent call last):
    # ...
    # HTTPError: HTTP Error 500: Internal Server Error
    # >>> b.headers['bobo-exception-type']
    # 'HTTPFound'

We need to wrap around one of the interesting files inside with the
standard ExposureFile object.
::

    >>> file1 = u'file1'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile1 = context[file1]
    >>> efile1
    <ExposureFile at ...>

We need a way to get to the content of the file.  I have generalized the
required methods into its own adapter, so we utilize it and call the
method that will return the source
::

    >>> pmr2hgtest = self.portal.workspace.pmr2hgtest
    >>> helper = zope.component.queryAdapter(efile1, IExposureSourceAdapter)
    >>> answer = (context, pmr2hgtest, 'file1')
    >>> result = helper.source()
    >>> answer == result
    True

The adapter also provides a method that returns the contents of the file
that this represents.
::

    >>> helper.file()
    'This is file1, initial commit.\n'

Test it with the default view.  There should be no adapters added yet.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
    </dl>

Calling render on the parent exposure should result in a redirection to
this exposure file.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureInfo(context, request)
    >>> view.update()
    >>> result = view.render()
    >>> request.response.getHeader('Location')
    '.../file1/view'

The redirect view should redirect to the actual file within the 
workspace.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileRedirect(context[file1], request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/pmr2hgtest/@@rawfile/.../file1'

Now we do the same with our set of data, with more content.
::

    >>> rawrevs = [
    ...     '0',
    ...     '1',
    ...     '2',
    ...     '3',
    ... ]
    >>> rev = u'2'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'/plone/workspace/rdfmodel',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

In order to annotate views to a file, we need to wrap around the target 
files with the standard ExposureFile object.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> file1 = u'example_model.cellml'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> context[file1]
    <ExposureFile at ...>

We will use the annotation form, which will get the annotator and 
annotate our ExposureFile content object.  Of course, first we have to
see whether the form has the annotator we needed.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = browser.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> 'rdfturtle' in result
    True
    >>> 'rdfxml' in result  # for later usage
    True

Good, now we use that transform to generate the Turtle RDF.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rdfturtle'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
      <dt>rdfturtle</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.  Since we are constructing the view directly rather
than the component registry (as it is registered using the generated
class which we can't test in here), we manually assign its __name__

Also, the headers will need to be reassigned later as they are just
data (should not really be part of code).
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = browser.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfturtle'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>...
    @prefix...
    ...

We will do the same thing with the xml format.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rdfxml'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
      <dt>rdfturtle</dt>
      <dt>rdfxml</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.  Since we are constructing the view directly rather
than the component registry (as it is registered using the generated
class which we can't test in here), we manually assign its __name__.

Also, the titles and descriptions will need to be reassigned later as 
they are just data (should not really be part of code).
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = browser.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfxml'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;rdf:RDF
    ...

Of course assignment to this new set of data, it will not overwrite the
other note class because it has a distinct annotation key.
::

    >>> request = TestRequest()
    >>> view = browser.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfturtle'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>...
    @prefix...
    ...

This way it becomes a lot easier to provide new content and associated
views to a file that requires processing.  One only need to define an
ExposureFile adapter class and an utility class that will populate the
data for that class.  The view would then access the data stored within
that adapter.

It may be necessary to group some of these subparts together.  Since
all those views are derived from RDF, it makes sense to have a single
@@rdf view with subpaths to the particular format.  First we query the
view and see that it will return a list by default
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), name='rdf')
    >>> print view()
    <h3>RDF views available</h3>
    <p>The following is a list of available choices</p>
    <ul>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/n3">n3</a>
    </li>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/turtle">turtle</a>
    </li>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/xml">xml</a>
    </li>
    </ul>

If we define a valid subpath, it will give what we expect.
::

    >>> view.traverse_subpath = ['xml']
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;rdf:RDF
    ...

There are cases where user-edited notes are desired.  Here we test out 
editing first on the note editor/annotator
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'edited_note'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True
    >>> request.response.getHeader('Location')
    'http://.../example_model.cellml/@@note_editor/edited_note'

We should have been a redirect to the edit view.  The editor view is
defined without any default fields, so it must figure out the correct
fields from the name of the note from the URI supplied.  We replicate
what the request would see here and render the note edit view.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = ['edited_note']
    >>> result = view()
    >>> 'note' in result
    True

The form is rendered correctly when a defined subpath is supplied.  If
no subpath or one is not meant to be user editable is supplied, it will
result in a not found error.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = []
    >>> view()
    Traceback (most recent call last):
    ...
    NotFound: ...
    ...
    >>> view.traverse_subpath = ['rdf']
    >>> view()
    Traceback (most recent call last):
    ...
    NotFound: ...
    ...

Then apply on the edit form for the note, and the note will have its
field updated.
::

    >>> note = u'This is a test note'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.note': note,
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = ['edited_note']
    >>> result = view()

Now if we call the edited_note view for the file, the page will be
rendered.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='edited_note')
    >>> result = view()
    >>> print result
    Edited Note is: [This is a test note]

This should also be available as a new view that is attached to filectx.
::

    >>> 'edited_note' in filectx.views
    True

There are cases where user intervention is required for generating a
note from the file.  This example shows that a user may select the
number of characters from the original file to include in the resulting
note.  We will do this on a new file.
::

    >>> context['README'] = ExposureFile('README')
    >>> readmectx = context['README']
    >>> chars = u'15'
    >>> text = u'This will be replaced'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.chars': chars,
    ...         'form.widgets.text': text,
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureFileNoteEditForm(readmectx, request)
    >>> view.traverse_subpath = ['post_edited_note']
    >>> result = view()

The data should have been generated correctly and the view rendered.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((readmectx, request), 
    ...                                         name='post_edited_note')
    >>> result = view()
    >>> print result
    Post Edited Note is: [15:This is an exam]

------------------------
Files within Directories
------------------------

We however only looked at files sitting at the root level.  There are
many cases where files will be nested within some directory level which
we have not looked at yet.  Let's see what happens when we try that.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path2 = (u'component', u'module.cellml')
    >>> file2 = '/'.join(path2)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file2],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

It should also be able to redirect to the correct file within its source
workspace.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileRedirect(efile2, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/module.cellml'

Calling render on the parent of this file should also result in a 
redirection to much like the root object.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureInfo(context[path2[0]], request)
    >>> view.update()
    >>> result = view.render()
    >>> request.response.getHeader('Location')
    '.../component/module.cellml/view'

We can try the same with another nested file.  Since the 'component'
folder is already created, it should not be recreated and reused and
remain accessible.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path3 = (u'component', u'docs', u'index.html')
    >>> file3 = '/'.join(path3)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file3],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile3 = context[path3[0]][path3[1]][path3[2]]
    >>> efile3
    <ExposureFile at ...>
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

Again, redirection should remain in place.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureFileRedirect(efile3, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.html'

One more time, with the other index file, and go straight to testing
the redirection view.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path4 = (u'component', u'docs', u'index.rst')
    >>> file4 = '/'.join(path4)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file4],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile4 = context[path4[0]][path4[1]][path4[2]]
    >>> request = TestRequest()
    >>> view = browser.ExposureFileRedirect(efile4, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.rst'

In this case, on this particular level (/component/docs/) there are now
two files - this should disable the redirection of the ExposureInfo 
view.
::

    >>> request = TestRequest()
    >>> view = browser.ExposureInfo(context[path4[0]][path4[1]], request)
    >>> view.update()
    >>> result = view.render()
    >>> request.response.getHeader('Location')
    >>> print result
    <h1 class="documentFirstHeading">docs</h1>
    <div id="content-core">
      <div></div>
    </div>

It is possible to define a custom note adapter with its own view and
annotator to store custom-defined values, and this is the preferred
method for it allows plugin writers to define exactly how the data is
to be generated, stored, and presented.

While it is possible to rely on multiple note adapters to achieve the
same goal, it cannot be guarantee that the stored data can be accessed
correctly for the adapters relied on may change or become absent, thus
potentially breaking the annotators and cause data loss.

---------------------
Default Document View
---------------------

This is the case where multiple generators can be used to result in a
same view.  Since the ExposureFile is built on top of the standard 
Document archetype, we may have different file formats that require
different rendering methods.

For the HTML file
::

    >>> filectx = efile3
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureDocViewGenForm(filectx, request)
    >>> result = view()
    >>> filectx.Title()
    'Simple HTML'
    >>> filectx.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> filectx.docview_generator
    u'safe_html'

For the reStructureText file
::

    >>> filectx = efile4
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [],
    ...         'form.widgets.docview_generator': [u'rest_to_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = browser.ExposureDocViewGenForm(filectx, request)
    >>> result = view()
    >>> filectx.getText()
    '<h2 class="title">Simple reStructureText</h2>\n<p>...</p>\n'
    >>> filectx.docview_generator
    u'rest_to_html'

As the annotator classes are separate from the data adapters, we can
easily reuse them for the other types, such as the default view of the
Exposures.  With this form we pick a file for the source of our text,
and the annotator to process it with.  We can pick any file.

This method however is superceded by the docgen annotation.
::

    >>> context
    <Exposure at ...>
    >>> source_file = u'component/docs/index.html'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='docviewgen')
    >>> result = view()
    >>> result
    ''
    >>> context.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> context.docview_generator
    u'safe_html'
    >>> context.docview_gensource == source_file
    True

ExposureFiles can also reference a separate file for its documentation.
::

    >>> source_file = u'component/docs/index.html'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((efile2, request), 
    ...                                         name='docviewgen')
    >>> result = view()
    >>> result
    ''
    >>> efile2.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> efile2.docview_generator
    u'safe_html'
    >>> efile2.docview_gensource == source_file
    True

Ditto for ExposureFolders.
::

    >>> source_file = u'component/README'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> edir1 = context[path4[0]]
    >>> view = zope.component.queryMultiAdapter((edir1, request), 
    ...                                         name='docviewgen')
    >>> result = view()
    >>> result
    ''
    >>> 'This is a readme file inside the component directory.' in \
    ...     edir1.getText()
    True
    >>> edir1.docview_generator
    u'safe_html'
    >>> edir1.docview_gensource == source_file
    True

We could try to render it, and this will be done on the html file at
`component/docs/index.html`.
::

    >>> filectx = efile3
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                         name='exposure_file_document_view')
    >>> result = view()
    >>> 'Lorem ipsum dolar sit amet' in result
    True

So standard document view is rendered.  We can now select one of the
annotations as the default view, using the form.  First we render the
form and make sure the choices are all rendered.  The file we will use
is `example_model.cellml`.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view()
    >>> [i in result for i in filectx.views]
    [True, True, True]

Now select one of those views to change the default view from the
document_view to one provided by the notes.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.selected_view': [u'edited_note'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view()
    >>> filectx.selected_view == u'edited_note'
    True

The view should render with the edited_note as selected.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view()
    >>> u'selected="selected">edited_note</option>' in result
    True

What if the views that are saved had been changed or removed?  The form
should not break because the selection is no longer there.
::

    >>> views = filectx.views  # save original value
    >>> filectx.views = []
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='select_view')
    >>> result = view()
    >>> u'edited_note' not in result
    True
    >>> filectx.views = views  # reset original value

Now the same document view rendering will result in the same view as the
edited_note.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                         name='exposure_file_document_view')
    >>> result = view()
    >>> print result
    Edited Note is: [This is a test note]

-----------------
Exposure Rollover
-----------------

As exposures are pinned to specific revisions even though new changesets
are added.  Users may want to have a new exposure point to a newer
revision but not want to manually readd to recreate the exposure and its
associated files.  The feature 'Exposure Rollover' is introduced to 
automate the process of recreating the files and its associated views.

(Yes, the following should have its own unit tests, but for now we at
least need some integration/functional tests)

First a structure that represents an exposure is generated, which
contains all the information required to automatically regenerate an 
identical new object hierarchy if all files exists at the newly pinned
commit id.  We will use the data we created from above, and call the 
utility defined for this task.
::

    >>> context
    <Exposure at /.../exposure/...>
    >>> context.curation = {'key': ['value1', 'value2']}
    >>> context.setSubject(('Test',))
    >>> request = TestRequest()
    >>> porter = browser.ExposurePort(context, request)
    >>> result = list(porter.export())
    >>> answer = [
    ...     ('example_model.cellml', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'hidden_views': [],
    ...         'views': [
    ...             (u'rdfturtle', None),
    ...             (u'rdfxml', None),
    ...             (u'edited_note', {
    ...                 'note': u'This is a test note',
    ...             }),
    ...         ],
    ...         'selected_view': u'edited_note',
    ...         'Subject': (),
    ...     }),
    ...     ('README', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'hidden_views': [],
    ...         'views': [
    ...             (u'post_edited_note', {
    ...                 'chars': 15,
    ...                 'text': u'This is an exam',
    ...             }),
    ...         ],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/module.cellml', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'hidden_views': [],
    ...         'views': [],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/docs/index.html', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'hidden_views': [],
    ...         'views': [],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/docs/index.rst', {
    ...         'file_type': None,
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'hidden_views': [],
    ...         'views': [],
    ...         'selected_view': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component/docs', {
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'Subject': (),
    ...     }),
    ...     ('component', {
    ...         'docview_gensource': u'component/README',
    ...         'docview_generator': u'safe_html',
    ...         'Subject': (),
    ...     }),
    ...     ('', {
    ...         'commit_id': u'2',
    ...         'curation': {'key': ['value1', 'value2']},
    ...         'docview_generator': u'safe_html',
    ...         'docview_gensource': u'component/docs/index.html',
    ...         'title': u'Simple HTML',
    ...         'workspace': u'/plone/workspace/rdfmodel',
    ...         'Subject': ('Test',),
    ...     })
    ... ]
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Once we know it will return the expected structure, we can expect the
porter to be able to recreate the same exposure with the same commit.
First we need need a new exposure object.
::

    >>> old_ex = context
    >>> eaf = browser.ExposureAddForm(self.portal.exposure, None)
    >>> rawrev = rawrevs[2]
    >>> rev = unicode(rawrev)
    >>> data = {
    ...     'workspace': u'/plone/workspace/rdfmodel',
    ...     'curation': None,
    ...     'commit_id': rev,
    ... }
    >>> obj = eaf.createAndAdd(data)
    >>> exp_id = data['id']
    >>> new_ex = self.portal.exposure[exp_id]
    >>> new_ex
    <Exposure at /.../exposure/...>
    >>> new_ex == old_ex
    False

Now we use the porter to mold the new exposure based on what it knows.
::

    >>> porter.mold(new_ex)
    >>> newport = browser.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

The ExposurePort class can be subclassed into customized forms, 
depending on how the upgrade process is presented.  Here we have a form
that is based on the old context, takes the next commit id.  We can
supply an existing commit id.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='rollover')
    >>> result = view()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex = self.portal.exposure[new_id]
    >>> newport = browser.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

It should work for all other commits.  The only difference would be the
edited note.  We will need to make a deep copy of the original answer
and update the post edited note with the contents of the file in that
commit.
::

    >>> from copy import deepcopy
    >>> rev2_answer = answer
    >>> rev = unicode(rawrevs[3])
    >>> answer = deepcopy(answer)
    >>> answer[-1][1]['commit_id'] = rev
    >>> answer[1][1]['views'] = [
    ...         (u'post_edited_note', {
    ...             'chars': 15,
    ...             'text': u'README for this',
    ...         }),
    ...     ]
    ...
    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='rollover')
    >>> result = view()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex = self.portal.exposure[new_id]
    >>> newport = browser.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Rollovers via workspace
-----------------------

Currently, the more accessible, easier to use form for this rollover
feature is attached to a view within workspaces.  We can achieve this
by instantiating the form from one.

First we verify that the form contain the fields we are interested in,
with the radio boxes available to be selected.
::

    >>> context = self.portal.workspace['rdfmodel']
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                          name='exposure_rollover')
    >>> view.update()
    >>> result = view()
    >>> '2' in result
    True
    >>> '<td><label><input type="radio" class="radio-widget" ' \
    ... 'name="form.widgets.commit_id" ' \
    ... 'value="3"  /> ' \
    ... '3</label></td>' in result
    True
    >>> '<input type="radio" class="radio-widget" ' \
    ... 'name="form.widgets.exposure_path"' in result
    True

Then we can submit the form, and see that the data has been ported to
the structure in the exposure wizard.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.widgets.exposure_path': '/plone/exposure/%s' % new_id,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> next_ex = view.target
    >>> wh = zope.component.getAdapter(next_ex, IExposureWizard)
    >>> result = wh.structure
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Errors cases
------------

There are ways to submit this form using bad information.  Those will 
need to be handled.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.widgets.exposure_path': '',
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view()
    >>> request.response.getHeader('Location')
    >>> data, errors = view.extractData()
    >>> len(errors)
    1

We should have seen that the form did not redirect and the error being
caused by the missing field.  The user should have saw the same form
with the commit_id remain selected.
::

    >>> '<td><label><input type="radio" class="radio-widget" ' \
    ... 'name="form.widgets.commit_id" ' \
    ... 'value="3" ' \
    ... 'checked="checked" />' in result
    True

If we flip this around and provide an empty id and a valid exposure
path:
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': u'',
    ...    'form.widgets.exposure_path': '/plone/exposure/%s' % new_id,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view()
    >>> request.response.getHeader('Location')
    >>> data, errors = view.extractData()
    >>> len(errors)
    1
    >>> ('<td><label><input type="radio" class="radio-widget" ' \
    ...  'name="form.widgets.exposure_path" ' \
    ...  'value="/plone/exposure/%s" ' \
    ...  'checked="checked" />' % new_id) in result
    True

Or completely bogus values:
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': u'fake',
    ...    'form.widgets.exposure_path': 'fake',
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view()
    >>> request.response.getHeader('Location')
    >>> 'There were some errors.' in result
    True

Exposure Rollover and changed default exposure subpath
------------------------------------------------------

In the case of having a new destination container due to changes in the
settings, there should be no issue as the full exposure path to the
source that is used.
::

    >>> self.portal['e'] = ExposureContainer('e')
    >>> settings.default_exposure_subpath = u'e'
    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.widgets.exposure_path': '/plone/exposure/%s' % new_id,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='exposure_rollover')
    >>> result = view()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../e/...
    >>> next_ex = view.target
    >>> wh = zope.component.getAdapter(next_ex, IExposureWizard)
    >>> result = wh.structure
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

As the exposure rollover now use the wizard as the intermediate step,
the final data will not be created until user triggers it.  Test to see
this step works by calling the associated methods that the wizard should
have used.
::

    >>> util.moldExposure(next_ex, request, wh.structure)

Then we try to extract that structure, and see this working.
::

    >>> nextport = browser.ExposurePort(next_ex, None)
    >>> result = list(nextport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Exposure Rollover json export
-----------------------------

To facilitate interoperability with other PMR2 instances, a page that
provide the structure of a given exposure can be exported.
::

    >>> import json
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((next_ex, request), 
    ...                                         name='wizard_exporter')
    >>> jsonstr = view()
    >>> '3' in jsonstr
    True

For compatibility with testing, we override the default pmr2 exposure
url opener with the one from the test browser so it can access the
nohost urls.
::

    >>> from Testing.testbrowser import Browser
    >>> b = Browser()
    >>> import pmr2.app.exposure.urlopen
    >>> pmr2.app.exposure.urlopen._opener = b.mech_browser

Also make the item public.
::

    >>> self.setRoles(('Manager',))
    >>> wft = getToolByName(self.portal, 'portal_workflow')
    >>> wft.doActionFor(next_ex, 'publish')

This URI can be used with the import group on the exposure creation
form.  Instead of manually assigning the initial documentation then
start from scratch with the wizard, with an export URI the initial
dataset can be populated.
::

    >>> wkspc = self.portal.workspace['rdfmodel']
    >>> export_uri = next_ex.absolute_url() + '/wizard_exporter'
    >>> request = TestRequest(form={
    ...     'exportimport.widgets.export_uri': export_uri,
    ...     'form.buttons.add': 1,
    ... })
    >>> form = workspace.CreateExposureForm(wkspc, request)
    >>> commit_id = rawrevs[-1]
    >>> form.traverse_subpath = [commit_id]
    >>> result = form()
    >>> next = request.response.getHeader('Location')
    >>> next
    'http://.../e/...'

The wizard annotation should contain this list.
::

    >>> wh = zope.component.getAdapter(form.ctxobj, IExposureWizard)
    >>> wh.structure == json.loads(jsonstr)
    True

Restore the url opener back to default.
::

    >>> pmr2.app.exposure.urlopen._opener = None
    >>> self.setRoles(('Member', 'Authenticated',))


Miscellenous
------------

A test case that demonstrates any issue with dealing with changes in the
list of files between the revision that are associated with an exposure
and the ones in the target revision within the source workspace, either
through rename/move or delete.

Also a test that verify that incompatible objects will not complicate
the rollover process (i.e. they be filtered out and ignored).

------------------
Exposure File Type
------------------

There are cases where specific types of files will always have the same
views generated.  PMR2 also provides a content type that enables users
to define a profile of sort for specific file types.  This allows the
annotation form to generate the correct views and arrange them in the
correct order, optinally select the right one, and tag the file with the
tags specified.

First we create one via the form.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.id': u'dummy_type',
    ...         'form.widgets.title': u'Dummy Type',
    ...         'form.widgets.views': u'edited_note\npost_edited_note',
    ...         'form.widgets.select_view': u'edited_note',
    ...         'form.widgets.tags': u'',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = browser.ExposureFileTypeAddForm(self.portal, request)
    >>> testform.update()
    >>> self.portal.dummy_type
    <ExposureFileType at /plone/dummy_type>
    >>> self.portal.dummy_type.views
    [u'edited_note', u'post_edited_note']
    >>> self.portal.dummy_type.tags
    []
    >>> self.portal.dummy_type.select_view
    u'edited_note'

This new data should have been indexed.
::

    >>> results = catalog(portal_type='ExposureFileType', id='dummy_type')
    >>> results[0].pmr2_eftype_views
    [u'edited_note', u'post_edited_note']
    >>> results[0].pmr2_eftype_tags
    []

The data could also be edited via the edit form.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.id': u'dummy_type',
    ...         'form.widgets.title': u'Dummy Type',
    ...         'form.widgets.views': u'rot13\n'
    ...                                'post_edited_note\n'
    ...                                'edited_note',
    ...         'form.widgets.select_view': u'post_edited_note',
    ...         'form.widgets.tags': u'Notes',
    ...         'form.buttons.apply': 1,
    ...     })
    >>> testform = browser.ExposureFileTypeEditForm(
    ...     self.portal.dummy_type, request)
    >>> testform.update()
    >>> self.portal.dummy_type.views
    [u'rot13', u'post_edited_note', u'edited_note']
    >>> self.portal.dummy_type.select_view
    u'post_edited_note'

The cataloged data should have been updated also.
::

    >>> results = catalog(portal_type='ExposureFileType', id='dummy_type')
    >>> results[0].pmr2_eftype_views
    [u'rot13', u'post_edited_note', u'edited_note']
    >>> results[0].pmr2_eftype_tags
    [u'Notes']
    >>> self.portal.dummy_type.select_view
    u'post_edited_note'

Before the next test, we need to publish the dummy type to make it
available for use.
::

    >>> self.setRoles(('Manager',))
    >>> wft = getToolByName(self.portal, 'portal_workflow')
    >>> wft.doActionFor(self.portal.dummy_type, 'publish')
    >>> self.setRoles(('Member', 'Authenticated',))

They will populate the selections available within the annotation by
filetype form.
::

    >>> request = TestRequest()
    >>> efile_new = new_ex.component.docs['index.html']
    >>> form = browser.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> 'Dummy Type' in result
    True
    >>> '/plone/dummy_type' in result
    False

We can choose to not use the predefined type and assign views manually,
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rot13', u'post_edited_note'],
    ...         'form.buttons.next': 1,
    ...     })
    >>> form = browser.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> request.response.getHeader('Location')
    'http://nohost/plone/.../@@edit_annotations'

The fields and the views selected should have been applied to our 
context.
::

    >>> efile_new.views
    [u'rot13', u'post_edited_note']
    >>> efile_new.file_type
    >>> efile_new.Subject()
    ()

Or chooose the defined type, which will assign the view, file type and
tag the file with the appropriate subjects.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.eftypes': [u'Dummy Type'],
    ...         'form.buttons.next': 1,
    ...     })
    >>> form = browser.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> request.response.getHeader('Location')
    'http://nohost/plone/.../@@edit_annotations'

The fields and the views selected should have been applied to our 
context.
::

    >>> efile_new.views
    [u'rot13', u'post_edited_note', u'edited_note']
    >>> efile_new.file_type
    '/plone/dummy_type'
    >>> efile_new.Subject()
    ('Notes',)

The next form should contain all the fields specified for editing.
::

    >>> request = TestRequest()
    >>> form = browser.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> form.update()
    >>> [g.fields.keys() for g in form.groups]
    [[], ['post_edited_note.chars'], ['edited_note.note']]

Rendering of the form should not cause side effects, which in this case
add the annotation to the context before the values are ready.
::

    >>> from pmr2.app.annotation.factory import has_note
    >>> True in [has_note(efile_new, name) for name in efile_new.views]
    False

When this form is sucessfully submitted, the annotations will be
generated and added.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.post_edited_note.chars': u'15',
    ...         'form.widgets.edited_note.note': u'User Edited Data.',
    ...         'form.buttons.apply': 1,
    ...     })
    >>> form = browser.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> result = form()

All three annotations should have worked, with its appropriate notes
generated.
::

    >>> n = zope.component.queryAdapter(efile_new, name='rot13')
    >>> n.text
    u'<ugzy>...
    >>> n = zope.component.queryAdapter(efile_new, name='post_edited_note')
    >>> n.chars
    15
    >>> n.text
    u'<html>\n<head><t'
    >>> n = zope.component.queryAdapter(efile_new, name='edited_note')
    >>> n.note
    u'User Edited Data.'

The other attributes to the exposure file should also have been set.
::

    >>> efile_new.selected_view
    u'post_edited_note'

When requesting this form again, the edited widgets should have the
values assigned above filled in.
::

    >>> from pmr2.testing.browser import GroupTemplate
    >>> request = TestRequest()
    >>> form = browser.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> form.template = GroupTemplate(form)
    >>> result = form()
    >>> u'User Edited Data.' in result
    True

Finally, we test that these data will also work with the migration.
::

    >>> rev = unicode(rawrevs[3])
    >>> answer[3][1]['file_type'] = '/plone/dummy_type'
    >>> answer[3][1]['Subject'] = ('Notes',)
    >>> answer[3][1]['selected_view'] = u'post_edited_note'
    >>> answer[3][1]['views'] = [
    ...         (u'rot13', None),
    ...         (u'post_edited_note', {
    ...             'chars': 15,
    ...             'text': u'<html>\n<head><t',
    ...         }),
    ...         (u'edited_note', {
    ...             'note': u'User Edited Data.',
    ...         }),
    ...     ]
    ...
    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((new_ex, request), 
    ...                                         name='rollover')
    >>> result = view()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex2 = self.portal.exposure[new_id]
    >>> newport = browser.ExposurePort(new_ex2, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

------------------
Note Rearrangement
------------------

There is also an edit view that will allow users to rearrange and/or
remove views.  It will remove any bad views.  First we render the form
::

    >>> ef = new_ex['example_model.cellml']
    >>> ef.views
    [u'rdfturtle', u'rdfxml', u'edited_note']
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((ef, request), 
    ...                                         name='arrange_views')
    >>> result = view()
    >>> '>rdfturtle\nrdfxml\nedited_note</textarea>' in result
    True

Now for the actual request to change values
::

    >>> request = TestRequest(form={
    ...    'form.widgets.views': u'edited_note\n'
    ...                           'rdfxml\n'
    ...                           'baddata\n'
    ...                           'rdfturtle\n',
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((ef, request), 
    ...                                         name='arrange_views')
    >>> result = view()
    >>> ef.views
    [u'edited_note', u'rdfxml', u'rdfturtle']


----------------------------------------
Document Generation (Annotation Version)
----------------------------------------

As part of the effort to unify the interfaces, the document generator is
moved into the annotation / exposure notes infrastructure.  Let's make
use of the predefined docgen type to test out the generation.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.eftypes': [u'Docgen Type'],
    ...         'form.buttons.next': 1,
    ...     })
    >>> form = browser.ExposureFileTypeChoiceForm(efile_new, request)
    >>> result = form()
    >>> u'docgen' in efile_new.views
    True
    >>> efile_new.file_type
    '/plone/docgen_type'

Now we submit the form with the desired information.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docgen.source': u'component/docs/index.html',
    ...         'form.widgets.docgen.generator': u'safe_html',
    ...         'form.buttons.apply': 1,
    ...     })
    >>> form = browser.ExposureFileTypeAnnotatorForm(efile_new, request)
    >>> result = form()

Data should be assigned properly.
::

    >>> efile_new.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
