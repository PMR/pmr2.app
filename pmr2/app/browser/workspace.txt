=========================================
Workspace Related Objects and Their Forms
=========================================

Before we get started, we need to import the required classes and set up
the test environment.
::

    >>> from pmr2.app.browser import workspace
    >>> from pmr2.app.tests.base import TestRequest
    >>> from plone.z3cform.tests import setup_defaults
    >>> from pmr2.app.content import *
    >>> self.folder.repo['workspace'] = WorkspaceContainer()
    >>> self.folder.repo.workspace
    <WorkspaceContainer at ...repo/workspace>
    >>> self.folder.repo.workspace['eggs'] = Workspace('eggs')
    >>> self.folder.repo.workspace.eggs
    <Workspace at ...repo/workspace/eggs>
    >>> request = TestRequest()

We will test the Repository Listing form first.  As the root object is
not configured, the listing will raise an exception which should not be
passed to the client.
::

    >>> repolist_page = workspace.WorkspaceContainerRepoListing(
    ...     self.folder.repo.workspace, request)
    >>> html = repolist_page()
    >>> 'Repository Path lookup failed.' in html
    True

The edit form for the Workspace should work.
::

    >>> testform = workspace.WorkspaceEditForm(
    ...     self.folder.repo.workspace.eggs, request)
    >>> html = testform()
    >>> 'Title' in html
    True
    >>> 'Description' in html
    True

Let's try to edit the Workspace with that form.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.title': u'Delicious Eggs',
    ...         'form.widgets.description': u'Test\nWorkspace',
    ...         'form.buttons.apply': 1,
    ...     })
    >>> testform = workspace.WorkspaceEditForm(
    ...     self.folder.repo.workspace.eggs, request)
    >>> testform.update()

Workspace is updated
::

    >>> self.folder.repo.workspace.eggs.title
    u'Delicious Eggs'
    >>> self.folder.repo.workspace.eggs.description
    u'Test\nWorkspace'

Now if we defined a temporary directory.  However, the workspace path
has not been created yet.
::

    >>> self.folder.repo.repo_root = self.tmpdir
    >>> self.folder.repo.repo_root == self.tmpdir
    True
    >>> repolist_page = workspace.WorkspaceContainerRepoListing(
    ...     self.folder.repo.workspace, request)
    >>> html = repolist_page()
    >>> 'Repository Path is undefined.' in html
    False
    >>> 'Workspace path is missing.' in html
    True

Once the required paths are created on the file system, the raw 
repository listing should render fine.
::

    >>> from pmr2.app.tests import utils
    >>> utils.mkreporoot(self.folder.repo.repo_root)
    >>> html = repolist_page()
    >>> 'eggs' in html
    True
    >>> 'Error' in html
    True
    >>> 'Valid' in html
    False

As the VCS instances are added to the file system, they should also
show up on the form.
::

    >>> utils.mkrepo(self.folder.repo.workspace.get_path(), 'ham')
    >>> html = repolist_page()
    >>> 'ham' in html
    True
    >>> 'Not Found' in html
    True

Now we create the repository for eggs.  It should no longer appear 
broken.
::

    >>> utils.mkrepo(self.folder.repo.workspace.get_path(), 'eggs')
    >>> html = repolist_page()
    >>> 'eggs' in html
    True
    >>> 'Error' in html
    False
    >>> 'Valid' in html
    True

Now we if try to create the ham workspace object using the 
WorkspaceStorageCreateForm, it will fail because the ham Storage object
already exists.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.id': u'ham',
    ...         'form.widgets.name': u'Tasty Ham',
    ...         'form.buttons.add': 1,
    ...     })
    ... 
    >>> testform = workspace.WorkspaceStorageCreateForm(
    ...     self.folder.repo.workspace, request)
    >>> html = testform()
    >>> 'A previous workspace' in html
    True

In this case, we need to use the standard add form which only creates
the workspace object and not the storage.
::

    >>> testform = workspace.WorkspaceAddForm(
    ...     self.folder.repo.workspace, request)
    >>> testform.update()

There should now be no repository objects without its respective
Workspace object.
::

    >>> html = repolist_page()
    >>> 'ham' in html
    True
    >>> 'Not Found' in html
    False

We can create a completely new workspace using the form we failed to use
earlier.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.id': u'cake',
    ...         'form.widgets.name': u'Delicious Cake',
    ...         'form.buttons.add': 1,
    ...     })
    ... 
    >>> testform = workspace.WorkspaceStorageCreateForm(
    ...     self.folder.repo.workspace, request)
    >>> testform.update()
    >>> p = utils.join(self.folder.repo.workspace.get_path(), 'cake')
    >>> utils.isdir(p)
    True
    >>> p = utils.join(self.folder.repo.workspace.get_path(), 'cake', '.hg')
    >>> utils.isdir(p)
    True

Now using the newly created workspace, try to render the file page, but
first we need to register the adapters.
::

    >>> from zope.component import provideAdapter
    >>> from zope.publisher.interfaces import IPublisherRequest
    >>> from pmr2.app.interfaces import IWorkspace
    >>> from pmr2.app.browser.interfaces import IPublishTraverse
    >>> from pmr2.mercurial.interfaces import IPMR2HgWorkspaceAdapter
    >>> from pmr2.mercurial.interfaces import IPMR2StorageBase
    >>> from pmr2.app.adapter import PMR2StorageRequestViewAdapter
    >>> provideAdapter(adapts=(
    ...                   IWorkspace, IPublisherRequest, IPublishTraverse,),
    ...                provides=IPMR2HgWorkspaceAdapter,
    ...                factory=PMR2StorageRequestViewAdapter,
    ...                name=u"PMR2StorageRequestView")

See if the page renders with expected output.
::

    >>> request = TestRequest()
    >>> testpage = workspace.WorkspaceFilePage(
    ...     self.folder.repo.workspace.cake, request)
    >>> testpage.update()
    >>> result = testpage()
    >>> '<th>Filename</th>' in result
    True
    >>> testpage.label
    u'Manifest: cake @ 0000000000 / '

The log page should render, too.
::

    >>> request = TestRequest()
    >>> testpage = workspace.WorkspaceLog(
    ...     self.folder.repo.workspace.cake, request)
    >>> result = testpage()
    >>> '<th>Log</th>' in result
    True

Now the short log page should render, too.
::

    >>> request = TestRequest()
    >>> testpage = workspace.WorkspaceShortlog(
    ...     self.folder.repo.workspace.cake, request)
    >>> result = testpage()
    >>> '<th>Log</th>' in result
    True

Main page should render fine, too.
::

    >>> request = TestRequest()
    >>> testpage = workspace.WorkspacePage(
    ...     self.folder.repo.workspace.cake, request)
    >>> result = testpage()
    >>> '<th>Log</th>' in result
    True

-----------
Actual Data
-----------

Here we will use data from a real repository with actual data.  The
method to extract archive of the test repo will be called.
::

    >>> self.createRepo()
    >>> request = TestRequest()
    >>> wkspc = self.folder.repo.workspace.pmr2hgtest
    >>> testpage = workspace.WorkspacePage(wkspc, request)
    >>> result = testpage()
    >>> '<th>Log</th>' in result
    True
    >>> len([i for i in self.pmr2hgtest_revs if i in result]) == len(
    ...     self.pmr2hgtest_revs)
    True

Now for a file listing.
::

    >>> request = TestRequest()
    >>> testpage = workspace.WorkspaceFilePage(wkspc, request)
    >>> testpage.update()
    >>> result = testpage()
    >>> label = u'Manifest: pmr2hgtest @ %s / ' % self.pmr2hgtest_revs[-1][:10]
    >>> testpage.label == label
    True
    >>> 'file1' in result
    True
    >>> 'file2' in result
    True
    >>> 'README' in result
    True

Subdirectories should work.  We use a different repo for this that has
the subdirectories in place, and we do need a proper revision for the
request_subpath.
::

    >>> wkspc = self.folder.repo.workspace.rdfmodel
    >>> subpath = self.rdfmodel_revs[-1:] + ['component']
    >>> request = TestRequest()
    >>> testpage = workspace.WorkspaceFilePage(wkspc, request)
    >>> testpage.traverse_subpath = subpath  
    >>> testpage.update()
    >>> result = testpage()
    >>> label = u'Manifest: rdfmodel @ %s / %s' % (subpath[0][:10], subpath[1])
    >>> testpage.label == label
    True
    >>> 'module.cellml' in result
    True

Bad revision results in not found.
::

    >>> subpath = ['abcdef1234567890', 'component']
    >>> request = TestRequest()
    >>> testpage = workspace.WorkspaceFilePage(wkspc, request)
    >>> testpage.traverse_subpath = subpath  
    >>> testpage.update()
    Traceback (most recent call last):
    ...
    HTTPNotFound: 404 Not Found
    ...

More tests to be done when I figure out how to test interactions with
Mercurial client for complete test.  This can be manually driven at this
point, since during deployment this functionality is vital and may be
hindered by network access failures.
