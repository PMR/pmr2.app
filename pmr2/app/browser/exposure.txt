==================================
Exposure Related Objects and Forms
==================================

Before we get started, we need to import the required classes.  The
directories required should have been already set up by the script.
::

    >>> from pprint import pprint
    >>> from zope import interface
    >>> import zope.component
    >>> from plone.z3cform.tests import setup_defaults
    >>> from pmr2.app.browser import workspace, exposure
    >>> from pmr2.app.tests.base import TestRequest
    >>> from pmr2.app.content import *
    >>> from pmr2.app.interfaces import *
    >>> from pmr2.app.content.interfaces import *
    >>> pp = lambda x: pprint(x, indent=4, width=1)

Create the exposure container.
::

    >>> self.portal['exposure'] = ExposureContainer()
    >>> self.portal.exposure
    <ExposureContainer at /plone/exposure>

Exposure container creates new exposure, we test it here.  It should be
a 32 byte long hex string.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'eggs',
    ...         'form.widgets.commit_id': u'00000000',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> oid = self.portal.exposure.objectIds()[0]
    >>> len(oid)
    32

Exposure object is created with fields properly populated.
::

    >>> self.portal.exposure[oid].workspace
    u'eggs'
    >>> self.portal.exposure[oid].commit_id
    u'00000000'

=======================
Exposure Traversal Page
=======================

Files within the workspace may link to other resources within it using 
relative links, with those links being incorporated into the resulting 
exposure pages, those links will become broken within Plone as they will
not exist in there.  Since creating every object within Plone is not
practical as they can be found from the workspace object, we redirect
requests to those relative links using the path fragments captured using
the pre-traversal hook in the exposure container object.

Here is an example of how it may work.  We have to mock up some objects
as we are only demonstrating how this view can work.  This first example
is the default view, with no request_subpath fragments.
::

    >>> class TestExposure(object):
    ...     interface.implements(IExposure)
    ...     commit_id = '000000000'
    ...
    >>> class TestPage(exposure.ExposureTraversalPage):
    ...     def render(self):
    ...         return u'render'
    ...     def path_to_uri(self):
    ...         filepath = '/'.join(self.request['request_subpath'])
    ...         return 'workspace/%s/%s' % (self.context.commit_id, filepath)
    ...
    >>> context = TestExposure()
    >>> request = TestRequest()
    >>> view = TestPage(context, request)
    >>> view()
    u'render'

Now if the ExposureContainer object has trapped a request_subpath
fragment, it should do a redirect.
::

    >>> request = TestRequest(request_subpath=['test.png'])
    >>> view = TestPage(context, request)
    >>> view()
    'workspace/000000000/test.png'
    >>> request.response.getHeader('Location')
    'workspace/000000000/test.png'

If a request_subpath does not resolve to a valid resource, redirects
are generated anyway since workspace can resolve it (no need to check
twice).
::

    >>> request = TestRequest(request_subpath=['fail.path'])
    >>> view = TestPage(context, request)
    >>> view()
    'workspace/000000000/fail.path'

Of course within the workspace, an HTTP Not Found would be triggered.

There are some caveats, it has to do with existing objects:

- Resolved views (@@, ++resource++) and existing objects in Plone have 
  priority, so those relative links will actually point to those views
  (note: traversal path is resolved not here, but in context; see
  pmr2.app.mixin).  This can cause security issues if those views are 
  not built with security in mind (they should be built to resist CSRF 
  anyway).

- Folders in Plone will definitely break the subpath resolution as they 
  prevent ExposureContainer (which implements the mixin class mentioned
  above) from doing its job.  A customized Folder class will need to be
  implemented to use that mixin and do its own resolution (or pass that
  job the ExposureContainer parent).


------------------------------------------------------------------------

========================
Exposure Files and Notes
========================

How exposures were originally implemented results in an explosion of
objects, as a result from one-to-many mapping from file to objects.

In the redesign introduced in v0.2, there is now only one object type
and only one of them per file.  Each of them will reference its source
file, and the custom views and data within are provided by adapters
which is extended off a standard adapter type.  The data generation is
no longer part of that class but be placed in its own, which can also be 
inherited to be reused by more complicated data processing methods.

This generalization will unify all views in the repository, result in
a standardized front page for each exposure and is significantly cleaner
than before.

-----------------------
Implementation Overview
-----------------------

To implement this feature, we will result in having objects in the
exposures having the exact same name as the file it represents.  This
will then require specific views to be registered for that content type
and have the view adapt to the correct persistent class it represents.

For example, in the workspace (http://models.example.com/w/test/) we 
have this directory structure:

  +\ ./
    | documentation.html
    | diagram.svg
   +\ import/
     | component-1.cellml
     | component-2.cellml
     | diagram.png
    | main-model.cellml
    | main-model_a.cellml
    | main-model_b.cellml

We must retain the access to the files as is.  However, sometimes it may
be beneficial to override that access to prevent certain kinds of attack
vectors.  For instance, documentation.html could contain scripts that
enable XSS attacks, so direct access to them through the exposure must
be sanitized (whereas through the workspace they must be sent as an
attachment).  The wrapper will also wrap the content of that file into
the page template.

Whereas the CellML files will need to be sent as raw, or rather be
redirected to the actual file, but then they do benefit from having
customized views (i.e. exposure pages).  The original implementation is
to add filename extensions to it, but ultimately this is proved to be
unflexible and clumsy - the hierarchy is all emulated, resulting in a
confused perception of the definitions of exposure pages and exposure
subpages.

Also, the original implementation does not include directories.

What I want is this - an object that can either refer to its real self
or the sanitized view (in the exposure), and to be able to provide
customized subviews.  More examples:

In exposure http://models.example.com/e/test/ (references same workspace
as above), we can have these objects:

  +\ ./
    | documentation.html
   +\ diagram.svg/
     | large.png
     | small.png
     | thumbnail.png
   +\ import/
    +\ component-1.cellml/
      | index
    +\ component-2.cellml/
      | index
    +\ diagram.png/
      | thumbnail.png
   +\ main-model.cellml/
     | index
     | metadata
     | code
   +\ main-model_a.cellml/
     | index
     | metadata
     | code
   +\ main-model_b.cellml/
     | index
     | metadata
     | code

Exposures require a descriptive index page that will give a complete
overview of what the model is, namely the curation status, key curation
information (citation and/or model authorship).  It will also list the
model files (usually are variants), giving a quick description of it 
based on metadata.

The object with the same name as the files in the workspace must be
able to perform these tasks:

  - get to the original file if configuration allows
  - present default views
  - also allow other custom views
  - contain other objects.

Each of these pages are not going to have its dedicated class (i.e. only
one page class), but adapters will be registered and will be used to
render and display.  Each of these pages will store the name of the
adapter used.  

Changes proposed here will mean redirections from the PMR2 v0.1 pages
to the new ones will need to take place.

In brief, there are these datatypes.

ExposureFolder
    Folder like object that exists solely to replicate any directory
    structures within its parents workspace.

ExposureFile
    Object in an Exposure that encapsulates its respective file within
    its parent's workspace.  May be nested inside ExposureFolder.

ExposureFileNote
    Persistent and Contained objects that wraps around the ExposureFile
    type.  Multiple ExposureFileAnnotator may make use of a single one
    of these.

    Views will need to be registered with ExposureFile, and those views
    will make use of these adapters
 
ExposureFileAnnotators
    Class that provides a generator method that will process the data.
    There may be different annotators that will use the same adapter
    types.

Associated Views
    Views are not exclusive with adapters, it just make use of the
    results that are stored within the adapters.  It may need some kind
    of method to determine whether it is active or not for the given
    ExposureFile object, as the data it requires may or may not be
    generated or available.

------------
Demostration
------------

Disclaimer: The doctests here only test the "workflow" (not Plone
workflow but how the objects are created/used), there isn't enough
testing of individual adapters (i.e. unit tests) written.

For this demo, we need to create an actual environment such that the
full demo can be appreciated.  We will use the environment that is
built in setup (uses pmr2.mercurial.tests) and create the exposure using
a workspace with actual data.
::

    >>> rev = unicode(self.archive_revs[1])
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'pmr2hgtest',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

Now we have an exposure, try to use one of its default views on it.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureInfo(context, request)
    >>> print view.render()
    <div></div>

We need to wrap around one of the interesting files inside with the
standard ExposureFile object.
::

    >>> pmr2hgtest = self.portal.workspace.pmr2hgtest
    >>> file1 = u'file1'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile1 = context[file1]
    >>> efile1
    <ExposureFile at ...>

We need a way to get to the content of the file.  I have generalized the
required methods into its own adapter, so we utilize it and call the
method that will return the source
::

    >>> helper = zope.component.queryAdapter(efile1, IExposureSourceAdapter)
    >>> answer = (context, pmr2hgtest, 'file1')
    >>> result = helper.source()
    >>> answer == result
    True

The adapter also provides a method that returns the contents of the file
that this represents.
::

    >>> helper.file()
    'This is file1, initial commit.\n'

Test it with the default view.  There should be no adapters added yet.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
    </dl>

The redirect view should redirect to the actual file within the 
workspace.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(context[file1], request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/pmr2hgtest/@@rawfile/.../file1'

Now we do the same with our set of data, with more content.
::

    >>> rawrevs = [
    ...     'b94d1701154be42acf63ee6b4bd4a99d09ba043c',
    ...     '2647d4389da6345c26d168bbb831f6512322d4f9',
    ...     '006f11cd9211abd2a879df0f6c7f27b9844a8ff2',
    ... ]
    >>> rawrev = rawrevs[2]
    >>> rev = unicode(rawrev)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.workspace': u'rdfmodel',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.portal.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.portal.exposure[exp_id]
    >>> context
    <Exposure at ...>

Before we use the builder on our set of data, we test that the redirect
works.  Redirects are required because images or imports may be linked
relatively within the resulting text of a generated ExposureFile.  Since
the other object may not exist, the redirect exists to connect it back
to the source file which lives in the workspace.
::

    >>> request = TestRequest(request_subpath=['README'])
    >>> view = exposure.ExposureFolderListing(context, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    '.../workspace/rdfmodel/.../README'

Should work for other files within directories, too.
::

    >>> request = TestRequest(request_subpath=['component', 'README'])
    >>> view = exposure.ExposureFolderListing(context, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    '.../workspace/rdfmodel/.../component/README'

Redirection will work differently after the builder is used to generate
folders and files.  There are few examples of this after.

We need to wrap around one of the interesting files inside with the
standard ExposureFile object.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> file1 = u'example_model.cellml'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> context[file1]
    <ExposureFile at ...>

Redirect view will work on this.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(context[file1], request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../example_model.cellml'

We will use the annotation form, which will get the annotator and 
annotate our ExposureFile content object.  Of course, first we have to
see whether the form has the annotator we needed.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> 'rdfturtle' in result
    True
    >>> 'rdfxml' in result  # for later usage
    True

Good, now we use that transform to generate the Turtle RDF.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rdfturtle'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
      <dt>rdfturtle</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.  Since we are constructing the view directly rather
than the component registry (as it is registered using the generated
class which we can't test in here), we manually assign its __name__

Also, the headers will need to be reassigned later as they are just
data (should not really be part of code).
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfturtle'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>
    @prefix : 
    ...

We will do the same thing with the xml format.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'rdfxml'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Views generated for this file</h3>
    <dl>
      <dt>rdfturtle</dt>
      <dt>rdfxml</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.  Since we are constructing the view directly rather
than the component registry (as it is registered using the generated
class which we can't test in here), we manually assign its __name__.

Also, the titles and descriptions will need to be reassigned later as 
they are just data (should not really be part of code).
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfxml'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;rdf:RDF
    ...

Of course assignment to this new set of data, it will not overwrite the
other note class because it has a distinct annotation key.
::

    >>> request = TestRequest()
    >>> view = exposure.RawTextNote(filectx, request)
    >>> view.__name__ = 'rdfturtle'
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>
    @prefix : 
    ...

This way it becomes a lot easier to provide new content and associated
views to a file that requires processing.  One only need to define an
ExposureFile adapter class and an utility class that will populate the
data for that class.  The view would then access the data stored within
that adapter.

It may be necessary to group some of these subparts together.  Since
all those views are derived from RDF, it makes sense to have a single
@@rdf view with subpaths to the particular format.  First we query the
view and see that it will return a list by default
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), name='rdf')
    >>> view = view.form_instance  # take what we defined.
    >>> print view()
    <h3>RDF views available</h3>
    <p>The following is a list of available choices</p>
    <ul>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/n3">n3</a>
    </li>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/turtle">turtle</a>
    </li>
    <li>
      <a href="http://.../example_model.cellml/@@rdf/xml">xml</a>
    </li>
    </ul>

If we define a valid subpath, it will give what we expect.
::

    >>> view.traverse_subpath = ['xml']
    >>> print view()
    <h3>...</h3>
    <p>...
    <pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
    &lt;rdf:RDF
    ...

There are cases where user-edited notes are desired.  Here we test out 
editing first on the note editor/annotator
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotators': [u'edited_note'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotatorForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True
    >>> request.response.getHeader('Location')
    'http://.../example_model.cellml/@@note_editor/edited_note'

We should have been a redirect to the edit view.  The editor view is
defined without any default fields, so it must figure out the correct
fields from the name of the note from the URI supplied.  We replicate
what the request would see here and render the note edit view.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = ['edited_note']
    >>> result = view()
    >>> 'note' in result
    True

The form is rendered correctly when a defined subpath is supplied.  If
no subpath or one is not meant to be user editable is supplied, it will
result in a not found error.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = []
    >>> view()
    Traceback (most recent call last):
    ...
    HTTPNotFound: 404 Not Found
    ...
    >>> view.traverse_subpath = ['rdf']
    >>> view()
    Traceback (most recent call last):
    ...
    HTTPNotFound: 404 Not Found
    ...

Then apply on the edit form for the note, and the note will have its
field updated.
::

    >>> note = u'This is a test note'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.note': note,
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureFileNoteEditForm(filectx, request)
    >>> view.traverse_subpath = ['edited_note']
    >>> result = view()

Now if we call the edited_note view for the file, the page will be
rendered.
::

    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((filectx, request), 
    ...                                         name='edited_note')
    >>> result = view()
    >>> print result
    Edited Note is: [This is a test note]

------------------------
Files within Directories
------------------------

We however only looked at files sitting at the root level.  There are
many cases where files will be nested within some directory level which
we have not looked at yet.  Let's see what happens when we try that.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path2 = (u'component', u'module.cellml')
    >>> file2 = '/'.join(path2)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file2],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

It should also be able to redirect to the correct file within its source
workspace.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile2, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/module.cellml'

We can try the same with another nested file.  Since the 'component'
folder is already created, it should not be recreated and reused and
remain accessible.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path3 = (u'component', u'docs', u'index.html')
    >>> file3 = '/'.join(path3)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file3],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile3 = context[path3[0]][path3[1]][path3[2]]
    >>> efile3
    <ExposureFile at ...>
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

Again, redirection should remain in place.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile3, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.html'

One more time, with the other index file, and go straight to testing
the redirection view.
::

    >>> rdfmodel = self.portal.workspace.rdfmodel
    >>> path4 = (u'component', u'docs', u'index.rst')
    >>> file4 = '/'.join(path4)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file4],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile4 = context[path4[0]][path4[1]][path4[2]]
    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile4, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.rst'

For the other files that do not have the note adapter in place, there
should be a view defined such that they will still get redirected back
to it.  In this case, the path 'component/README' used to be accessible,
but now a folder had been created by some steps above.  Since the folder
object will be resolved, its default view should be acquired with a
proper request_subpath component added.  The request_subpath key within
request is generated by the mixin class, it is captured from traversal 
to this non-existent path by the user agent.  Please see ../mixin.py.
::

    >>> edir1 = context[path4[0]]
    >>> edir1
    <ExposureFolder at /.../component>
    >>> request = TestRequest(request_subpath=['README'])
    >>> view = exposure.ExposureFolderListing(edir1, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    '.../component/README'

It is possible to define a custom note adapter with its own view and
annotator to store custom-defined values, and this is the preferred
method for it allows plugin writers to define exactly how the data is
to be generated, stored, and presented.

While it is possible to rely on multiple note adapters to achieve the
same goal, it cannot be guarantee that the stored data can be accessed
correctly for the adapters relied on may change or become absent, thus
potentially breaking the annotators and cause data loss.

---------------------
Default Document View
---------------------

This is the case where multiple generators can be used to result in a
same view.  Since the ExposureFile is built on top of the standard 
Document archetype, we may have different file formats that require
different rendering methods.

For the HTML file
::

    >>> filectx = efile3
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureDocViewGenForm(filectx, request)
    >>> result = view()
    >>> filectx.Title()
    'Simple HTML'
    >>> filectx.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> filectx.docview_generator
    u'safe_html'

For the reStructureText file
::

    >>> filectx = efile4
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [],
    ...         'form.widgets.docview_generator': [u'rest_to_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = exposure.ExposureDocViewGenForm(filectx, request)
    >>> result = view()
    >>> filectx.getText()
    '<h2 class="title">Simple reStructureText</h2>\n<p>...</p>\n'
    >>> filectx.docview_generator
    u'rest_to_html'

As the annotator classes are separate from the data adapters, we can
easily reuse them for the other types, such as the default view of the
Exposures.  With this form we pick a file for the source of our text,
and the annotator to process it with.  We can pick any file.
::

    >>> context
    <Exposure at ...>
    >>> source_file = u'component/docs/index.html'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='docviewgen')
    >>> result = view.form_instance()
    >>> result
    ''
    >>> context.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> context.docview_generator
    u'safe_html'
    >>> context.docview_gensource == source_file
    True

ExposureFiles can also reference a separate file for its documentation.
::

    >>> source_file = u'component/docs/index.html'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((efile2, request), 
    ...                                         name='docviewgen')
    >>> result = view.form_instance()
    >>> result
    ''
    >>> efile2.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'
    >>> efile2.docview_generator
    u'safe_html'
    >>> efile2.docview_gensource == source_file
    True

Ditto for ExposureFolders.
::

    >>> source_file = u'component/README'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.docview_gensource': [source_file],
    ...         'form.widgets.docview_generator': [u'safe_html'],
    ...         'form.buttons.apply': 1,
    ...     })
    >>> view = zope.component.queryMultiAdapter((edir1, request), 
    ...                                         name='docviewgen')
    >>> result = view.form_instance()
    >>> result
    ''
    >>> edir1.getText()
    '<p>This is a readme file inside the component directory.</p>'
    >>> edir1.docview_generator
    u'safe_html'
    >>> edir1.docview_gensource == source_file
    True

-----------------
Exposure Rollover
-----------------

As exposures are pinned to specific revisions even though new changesets
are added.  Users may want to have a new exposure point to a newer
revision but not want to manually readd to recreate the exposure and its
associated files.  The feature 'Exposure Rollover' is introduced to 
automate the process of recreating the files and its associated views.

(Yes, the following should have its own unit tests, but for now we at
least need some integration/functional tests)

First a structure that represents an exposure is generated, which
contains all the information required to automatically regenerate an 
identical new object hierarchy if all files exists at the newly pinned
commit id.  We will use the data we created from above, and call the 
utility defined for this task.
::

    >>> context
    <Exposure at /.../exposure/...>
    >>> context.curation = {'key': ['value1', 'value2']}
    >>> porter = exposure.ExposurePort(context, None)
    >>> result = list(porter.export())
    >>> answer = [
    ...     ('example_model.cellml', {
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...         'views': [
    ...             (u'rdfturtle', None),
    ...             (u'rdfxml', None),
    ...             (u'edited_note', {
    ...                 'note': u'This is a test note',
    ...             }),
    ...         ]
    ...     }),
    ...     ('component/module.cellml', {
    ...         'docview_gensource': u'component/docs/index.html',
    ...         'docview_generator': u'safe_html',
    ...         'views': [],
    ...     }),
    ...     ('component/docs/index.html', {
    ...         'docview_gensource': None,
    ...         'docview_generator': u'safe_html',
    ...         'views': [],
    ...     }),
    ...     ('component/docs/index.rst', {
    ...         'docview_gensource': None,
    ...         'docview_generator': u'rest_to_html',
    ...         'views': [],
    ...     }),
    ...     ('component/docs', {
    ...         'docview_gensource': None,
    ...         'docview_generator': None,
    ...     }),
    ...     ('component', {
    ...         'docview_gensource': u'component/README',
    ...         'docview_generator': u'safe_html',
    ...     }),
    ...     ('', {
    ...         'commit_id': u'006f11cd9211abd2a879df0f6c7f27b9844a8ff2',
    ...         'curation': {'key': ['value1', 'value2']},
    ...         'docview_generator': u'safe_html',
    ...         'docview_gensource': u'component/docs/index.html',
    ...         'title': u'Simple HTML',
    ...         'workspace': u'rdfmodel',
    ...     })
    ... ]
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Once we know it will return the expected structure, we can expect the
porter to be able to recreate the same exposure with the same commit.
First we need need a new exposure object.
::

    >>> old_ex = context
    >>> eaf = exposure.ExposureAddForm(self.portal.exposure, None)
    >>> rawrev = rawrevs[2]
    >>> rev = unicode(rawrev)
    >>> data = {
    ...     'workspace': u'rdfmodel',
    ...     'curation': None,
    ...     'commit_id': rev,
    ... }
    >>> obj = eaf.createAndAdd(data)
    >>> exp_id = data['id']
    >>> new_ex = self.portal.exposure[exp_id]
    >>> new_ex
    <Exposure at /.../exposure/...>
    >>> new_ex == old_ex
    False

Now we use the porter to mold the new exposure based on what it knows.
::

    >>> porter.mold(new_ex)
    >>> newport = exposure.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

The ExposurePort class can be subclassed into customized forms, 
depending on how the upgrade process is presented.  Here we have a form
that is based on the old context, takes the next commit id.  We can
supply an existing commit id.
::

    >>> request = TestRequest(form={
    ...    'form.widgets.commit_id': rev,
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((context, request), 
    ...                                         name='rollover')
    >>> result = view.form_instance()
    >>> nextURL = request.response.getHeader('Location')
    >>> print nextURL
    http://.../exposure/...
    >>> new_id = nextURL.split('/')[-1]
    >>> new_ex = self.portal.exposure[new_id]
    >>> newport = exposure.ExposurePort(new_ex, None)
    >>> result = list(newport.export())
    >>> if not result == answer:
    ...     pp(answer)
    ...     pp(result)

Need to test this with the catalog, such that the results can still be
queried.

Also need to filter out incompatible objects.

------------------
Note Rearrangement
------------------

There is also an edit view that will allow users to rearrange and/or
remove views.  It will remove any bad views.  First we render the form
::

    >>> ef = new_ex['example_model.cellml']
    >>> ef.views
    [u'rdfturtle', u'rdfxml', u'edited_note']
    >>> request = TestRequest()
    >>> view = zope.component.queryMultiAdapter((ef, request), 
    ...                                         name='arrange_views')
    >>> result = view.form_instance()
    >>> '>rdfturtle\nrdfxml\nedited_note</textarea>' in result
    True

Now for the actual request to change values
::

    >>> request = TestRequest(form={
    ...    'form.widgets.views': u'edited_note\n'
    ...                           'rdfxml\n'
    ...                           'baddata\n'
    ...                           'rdfturtle\n',
    ...    'form.buttons.apply': 1,
    ... })
    >>> view = zope.component.queryMultiAdapter((ef, request), 
    ...                                         name='arrange_views')
    >>> result = view.form_instance()
    >>> ef.views
    [u'edited_note', u'rdfxml', u'rdfturtle']

======================
Notes/Question to Self
======================

Name to get to the notes (the annotations) can be different from the
name of the view that will use it because there are multiple annotators
(the generators) that may use the same EFNote class.  For instance, code
generation (view: /@@code/lang; data: note(context).code['lang'])*, 
document to html (which uses a marker as it reuses parent, which is an
ATDocument).  The note adapters manage the storage, the
view would need to figure out which one it is supposed to use.

* Code gen

  - could have different APIs to generate code, but somehow reuses the
  same storage adapter.

  - reuse the same storage class, but it could be stored under different 
  keys

Quick Usage Notes
-----------------

Someone wants to create a new view for a file.  Let's call it 'simple',
which will be accessible by http://.../fileobj/@@simple.  To register
the browser class, one can reuse/create an applicable subclass of the
ExposureFileViewBase browser class.

The storage of the final data will need to be defined also.  It is as
simple as defining a new factory with the same key as the view.
