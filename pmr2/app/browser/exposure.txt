==================================
Exposure Related Objects and Forms
==================================

Before we get started, we need to import the required classes.  The
directories required should have been already set up by the script.
::

    >>> from zope import interface
    >>> from plone.z3cform.tests import setup_defaults
    >>> from pmr2.app.browser import workspace, exposure
    >>> from pmr2.app.tests.base import TestRequest
    >>> from pmr2.app.content import *
    >>> from pmr2.app.interfaces import *

Create the exposure container.
::

    >>> self.folder.repo['exposure'] = ExposureContainer()
    >>> self.folder.repo.exposure
    <ExposureContainer at ...repo/exposure>

Exposure container creates new exposure, we test it here.  It should be
a 32 byte long hex string.
::

    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.title': u'Delicious Eggs',
    ...         'form.widgets.workspace': u'eggs',
    ...         'form.widgets.commit_id': u'00000000',
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.folder.repo.exposure, request)
    >>> testform.update()
    >>> oid = self.folder.repo.exposure.objectIds()[0]
    >>> len(oid)
    32

Exposure object is created with fields properly populated.
::

    >>> self.folder.repo.exposure[oid].title
    u'Delicious Eggs'

=======================
Exposure Traversal Page
=======================

Files within the workspace may link to other resources within it using 
relative links, with those links being incorporated into the resulting 
exposure pages, those links will become broken within Plone as they will
not exist in there.  Since creating every object within Plone is not
practical as they can be found from the workspace object, we redirect
requests to those relative links using the path fragments captured using
the pre-traversal hook in the exposure container object.

Here is an example of how it may work.  We have to mock up some objects
as we are only demonstrating how this view can work.  This first example
is the default view, with no request_subpath fragments.
::

    >>> testpaths = [
    ...     'test.cellml',
    ...     'test.png',
    ...     'folder/testcomp.cellml',
    ... ]
    ...
    >>> class TestExposure(object):
    ...     interface.implements(IExposure)
    ...
    ...     commit_id = '000000000'
    ...
    >>> class Resolver(object):
    ...     def path_to_uri(self, 
    ...             rev=None, filepath=None, view=None, validate=True):
    ...         if filepath not in testpaths:
    ...             return None
    ...         return 'workspace/%s/%s' % (rev, filepath)
    ...
    >>> class TestPage(exposure.ExposureTraversalPage):
    ...     @property
    ...     def uri_resolver(self):
    ...         return Resolver()
    ...     def render(self):
    ...         return u'render'
    ...
    >>> context = TestExposure()
    >>> request = TestRequest()
    >>> view = TestPage(context, request)
    >>> view()
    u'render'

Now if the ExposureContainer object has trapped a request_subpath
fragment, it should do a redirect.
::

    >>> request = TestRequest(request_subpath=['test.png'])
    >>> view = TestPage(context, request)
    >>> view()
    'workspace/000000000/test.png'
    >>> request.response.getHeader('Location')
    'workspace/000000000/test.png'

If a request_subpath does not resolve to a valid resource, HTTP 404 is
raised.
::

    >>> request = TestRequest(request_subpath=['fail.path'])
    >>> view = TestPage(context, request)
    >>> view()
    Traceback (most recent call last):
    ...
    HTTPNotFound: 404 Not Found
    ...

There are some caveats, it has to do with existing objects:

- Resolved views (@@, ++resource++) and existing objects in Plone have 
  priority, so those relative links will actually point to those views
  (note: traversal path is resolved not here, but in context; see
  pmr2.app.mixin).  This can cause security issues if those views are 
  not built with security in mind (they should be built to resist CSRF 
  anyway).

- Folders in Plone will definitely break the subpath resolution as they 
  prevent ExposureContainer (which implements the mixin class mentioned
  above) from doing its job.  A customized Folder class will need to be
  implemented to use that mixin and do its own resolution (or pass that
  job the ExposureContainer parent).


------------------------------------------------------------------------

=============================================================
Exposure implementation refactor in v0.2 (Currently Proposed)
=============================================================

How exposures were originally implemented results in an explosion of
objects, as a result from one-to-many mapping from file to objects.

In the redesign introduced in v0.2, there is now only one object type
and only one of them per file.  Each of them will reference its source
file, and the custom views and data within are provided by adapters
which is extended off a standard adapter type.  The data generation is
no longer part of that class but be placed in its own, which can also
be inherited to be reused by more complicated data processing methods.

This generalization will unify all views in the repository, result in
a standardized front page for each exposure and is significantly cleaner
than before.

-----------------------
Implementation Overview
-----------------------

To implement this feature, we will result in having objects in the
exposures having the exact same name as the file it represents.  This
will then require specific views to be registered for that content type
and have the view adapt to the correct persistent class it represents.

For example, in the workspace (http://models.example.com/w/test/) we 
have this directory structure:

  +\ ./
    | documentation.html
    | diagram.svg
   +\ import/
     | component-1.cellml
     | component-2.cellml
     | diagram.png
    | main-model.cellml
    | main-model_a.cellml
    | main-model_b.cellml

We must retain the access to the files as is.  However, sometimes it may
be beneficial to override that access to prevent certain kinds of attack
vectors.  For instance, documentation.html could contain scripts that
enable XSS attacks, so direct access to them through the exposure must
be sanitized (whereas through the workspace they must be sent as an
attachment).  The wrapper will also wrap the content of that file into
the page template.

Whereas the CellML files will need to be sent as raw, or rather be
redirected to the actual file, but then they do benefit from having
customized views (i.e. exposure pages).  The original implementation is
to add filename extensions to it, but ultimately this is proved to be
unflexible and clumsy - the hierarchy is all emulated, resulting in a
confused perception of the definitions of exposure pages and exposure
subpages.

Also, the original implementation does not include directories.

What I want is this - an object that can either refer to its real self
or the sanitized view (in the exposure), and to be able to provide
customized subviews.  More examples:

In exposure http://models.example.com/e/test/ (references same workspace
as above), we can have these objects:

  +\ ./
    | documentation.html
   +\ diagram.svg/
     | large.png
     | small.png
     | thumbnail.png
   +\ import/
    +\ component-1.cellml/
      | index
    +\ component-2.cellml/
      | index
    +\ diagram.png/
      | thumbnail.png
   +\ main-model.cellml/
     | index
     | metadata
     | code
   +\ main-model_a.cellml/
     | index
     | metadata
     | code
   +\ main-model_b.cellml/
     | index
     | metadata
     | code

Exposures require a descriptive index page that will give a complete
overview of what the model is, namely the curation status, key curation
information (citation and/or model authorship).  It will also list the
model files (usually are variants), giving a quick description of it 
based on metadata.

The object with the same name as the files in the workspace must be
able to perform these tasks:

  - get to the original file if configuration allows
  - present default views
  - also allow other custom views
  - contain other objects.

Each of these pages are not going to have its dedicated class (i.e. only
one page class), but adapters will be registered and will be used to
render and display.  Each of these pages will store the name of the
adapter used.  

Changes proposed here will mean redirections from the PMR2 v0.1 pages
to the new ones will need to take place.

In brief, there are these datatypes.

ExposureFolder
    Folder like object that exists solely to replicate any directory
    structures within its parents workspace.

ExposureFile
    Object in an Exposure that encapsulates its respective file within
    its parent's workspace.  May be nested inside ExposureFolder.

ExposureFileAdapters
    Persistent and Contained objects that wraps around the ExposureFile
    type.  Multiple ExposureFileAnnotator may make use of a single one
    of these.

    Views will need to be registered with ExposureFile, and those views
    will make use of these adapters
 
ExposureFileAnnotators
    Class that provides a generator method that will process the data.
    There may be different annotators that will use the same adapter
    types.

Associated Views
    Views are not exclusive with adapters, it just make use of the
    results that are stored within the adapters.  It may need some kind
    of method to determine whether it is active or not for the given
    ExposureFile object, as the data it requires may or may not be
    generated or available.

------------
Demostration
------------

For this demo, we need to create an actual environment such that the
full demo can be appreciated.  We will use the environment that is
built in setup (uses pmr2.mercurial.tests) and create the exposure using
a workspace with actual data.
::

    >>> rev = unicode(self.archive_revs[1])
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.title': u'PMR2 HgTest',
    ...         'form.widgets.workspace': u'pmr2hgtest',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.folder.repo.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.folder.repo.exposure[exp_id]
    >>> context
    <Exposure at ...>

Now we have an exposure, try to use one of its default views on it.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureInfo(context, request)
    >>> view.render()
    u'<h1>...

We need to wrap around one of the interesting files inside with the
standard ExposureFile object.
::

    >>> pmr2hgtest = self.folder.repo.workspace.pmr2hgtest
    >>> file1 = u'file1'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> context[file1]
    <ExposureFile at ...>

Try the file method to get the content of the file.  The reason this
method exist in this class is to serve as a helper to retrieve content,
not as something for views to use.  May be better served by an adapter.
::

    >>> context[file1].file()
    'This is file1, initial commit.\n'

The object a method that returns a tuple of its source:
::

    >>> answer = (context, pmr2hgtest, 'file1')
    >>> result = context[file1].source()
    >>> answer == result
    True

Test it with the default view.  There should be no adapters added yet.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Annotations attached to this file</h3>
    <dl>
    </dl>

The redirect view should redirect to the actual file within the 
workspace.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(context[file1], request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/pmr2hgtest/@@rawfile/.../file1'

Now we do the same with our set of data, with more content.
::

    >>> rawrevs = [
    ...     'b94d1701154be42acf63ee6b4bd4a99d09ba043c',
    ...     '2647d4389da6345c26d168bbb831f6512322d4f9',
    ...     '006f11cd9211abd2a879df0f6c7f27b9844a8ff2',
    ... ]
    >>> rawrev = rawrevs[2]
    >>> rev = unicode(rawrev)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.title': u'PMR2 Rdfmodel Test',
    ...         'form.widgets.workspace': u'rdfmodel',
    ...         'form.widgets.commit_id': rev,
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureAddForm(
    ...     self.folder.repo.exposure, request)
    >>> testform.update()
    >>> exp_id = testform._data['id']
    >>> context = self.folder.repo.exposure[exp_id]
    >>> context
    <Exposure at ...>

We need to wrap around one of the interesting files inside with the
standard ExposureFile object.
::

    >>> rdfmodel = self.folder.repo.workspace.rdfmodel
    >>> file1 = u'example_model.cellml'
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file1],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> context[file1]
    <ExposureFile at ...>

Redirect view will work on this.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(context[file1], request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../example_model.cellml'

We will use the annotation form, which will get the annotator and 
annotate our ExposureFile content object.  Of course, first we have to
see whether the form has the annotator we needed.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.ExposureFileAnnotationForm(filectx, request)
    >>> result = view()
    >>> 'RDFTurtle' in result
    True

Good, now we use that transform to generate the Turtle RDF.
::

    >>> filectx = context[file1]
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotator': [u'RDFTurtle'],
    ...         'form.buttons.add': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotationForm(filectx, request)
    >>> result = view()
    >>> result == ''
    True

Now the default view should show the new adapter.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileInfo(context[file1], request)
    >>> print view.content()
    <h3>Annotations attached to this file</h3>
    <dl>
      <dt>RDFTurtle</dt>
    </dl>

Which the associated view should then work with the original 
ExposureFile object.
::

    >>> filectx = context[file1]
    >>> request = TestRequest()
    >>> view = exposure.RDFTurtle(filectx, request)
    >>> print view()
    <h3>Metadata: Turtle Representation</h3>
    <p>The following is a Turtle representation of the RDF graph ...
    <pre><code>
    @prefix : 
    ...

This way it becomes a lot easier to provide new content and associated
views to a file that requires processing.  One only need to define an
ExposureFile adapter class and an utility class that will populate the
data for that class.  The view would then access the data stored within
that adapter.

We however only looked at files sitting at the root level.  There are
many cases where files will be nested within some directory level which
we have not looked at yet.  Let's see what happens when we try that.
::

    >>> rdfmodel = self.folder.repo.workspace.rdfmodel
    >>> path2 = (u'component', u'module.cellml')
    >>> file2 = '/'.join(path2)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file2],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

It should also be able to redirect to the correct file within its source
workspace.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile2, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/module.cellml'

We can try the same with another nested file.  Since the 'component'
folder is already created, it should not be recreated and reused and
remain accessible.
::

    >>> rdfmodel = self.folder.repo.workspace.rdfmodel
    >>> path3 = (u'component', u'docs', u'index.html')
    >>> file3 = '/'.join(path3)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file3],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile3 = context[path3[0]][path3[1]][path3[2]]
    >>> efile3
    <ExposureFile at ...>
    >>> efile2 = context[path2[0]][path2[1]]
    >>> efile2
    <ExposureFile at ...>

Again, redirection should remain in place.
::

    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile3, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.html'

One more time, with the other index file, and go straight to testing
the redirection view.
::

    >>> rdfmodel = self.folder.repo.workspace.rdfmodel
    >>> path4 = (u'component', u'docs', u'index.rst')
    >>> file4 = '/'.join(path4)
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.filename': [file4],
    ...         'form.buttons.add': 1,
    ...     })
    >>> testform = exposure.ExposureFileGenForm(context, request)
    >>> testform.update()
    >>> efile4 = context[path4[0]][path4[1]][path4[2]]
    >>> request = TestRequest()
    >>> view = exposure.ExposureFileRedirectView(efile4, request)
    >>> result = view()
    >>> request.response.getHeader('Location')
    'http://.../workspace/rdfmodel/@@rawfile/.../component/docs/index.rst'

Also, multiple adapters could generate content for a single view.  Since
we now base this on the standard Document archetype, we may allow
documents in various formats all generating output that will be stored
into the same view.  We have an annotator class that uses portal 
transforms to generate the content and store it into the original
context (which is an ATDocument in this implementation), we can just
define a standard type which the annotator will use as a marker to get
to the context.

For the HTML file
::

    >>> filectx = efile3
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotator': [u'safe_html'],
    ...         'form.buttons.add': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotationForm(filectx, request)
    >>> result = view()
    >>> filectx.getText()
    '\n<p>Lorem ipsum dolar sit amet</p>\n'

For the reStructureText file
::

    >>> filectx = efile4
    >>> request = TestRequest(
    ...     form={
    ...         'form.widgets.annotator': [u'rest_to_html'],
    ...         'form.buttons.add': 1,
    ...     })
    >>> view = exposure.ExposureFileAnnotationForm(filectx, request)
    >>> result = view()
    >>> filectx.getText()
    '<h2 class="title">Simple reStructureText</h2>\n<p>...</p>\n'

Hence annotator classes are separated from data adapters.  Of course,
this means if different annotator classes uses the same adapters the
data will be overwritten.  The registration and handling of these type
of conflicts will be addrssed in the future.
